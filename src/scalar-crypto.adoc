== Cryptography Extensions: Scalar & Entropy Source Instructions, Version 1.0.1

=== Changelog

[cols="1,5"]
|===
| Version | Changes

| `v1.0.1` 
| Fix typos to show that 
  `c.srli`, `c.srai`, and `c.slli` are Zkt instructions in RV64.

| `v1.0.0` 
| Initial Release
|===

[[crypto_scalar_introduction]]
=== Introduction

This document describes the _scalar_ cryptography
extension for RISC-V.
All instructions described herein use the general-purpose `X`
registers, and obey the 2-read-1-write register access constraint.
These instructions are designed to be lightweight and suitable
for `32` and `64` bit base architectures; from embedded IoT class
cores to large, application class cores which do not implement a
vector unit.

This document also describes the architectural interface to an
Entropy Source, which can be used to generate cryptographic secrets.
This is found in <<crypto_scalar_es>>.

It also contains a mechanism allowing core implementers to provide
_"Constant Time Execution"_ guarantees in <<crypto_scalar_zkt>>.

A companion document _Volume II: Vector Instructions_, describes
instruction proposals which build on the RISC-V Vector Extension.
The Vector Cryptography extension is currently a work in progress
waiting for the base Vector extension to stabilise.
We expect to pick up this work in earnest in Q4-2021 or Q1-2022.

[[crypto_scalar_audience]]
==== Intended Audience

Cryptography is a specialised subject, requiring people with many different
backgrounds to cooperate in its secure and efficient implementation.
Where possible, we have written this specification to be understandable by
all, though we recognise that the motivations and references to
algorithms or other specifications and standards may be unfamiliar to those
who are not domain experts.

This specification anticipates being read and acted on by various people
with different backgrounds.
We have tried to capture these backgrounds
here, with a brief explanation of what we expect them to know, and how
it relates to the specification.
We hope this aids people's understanding of which aspects of the specification
are particularly relevant to them, and which they may (safely!) ignore or
pass to a colleague.

Cryptographers and cryptographic software developers::
These are the people we expect to write code using the instructions
in this specification.
They should understand fairly obviously the motivations for the
instructions we include, and be familiar with most of the algorithms
and outside standards to which we refer.
We expect the sections on constant time execution
(<<crypto_scalar_zkt>>)
and the entropy source
(<<crypto_scalar_es>>)
to be chiefly understood with their help.

Computer architects::
We do not expect architects to have a cryptography background.
We nonetheless expect architects to be able to examine our instructions
for implementation issues, understand how the instructions will be used
in context, and advise on how best to fit the functionality the
cryptographers want to the ISA interface.

Digital design engineers & micro-architects::
These are the people who will implement the specification inside a
core. Again, no cryptography expertise is assumed, but we expect them to
interpret the specification and anticipate any hardware implementation
issues, e.g., where high-frequency design considerations apply, or where
latency/area tradeoffs exist etc.
In particular, they should be aware of the literature around efficiently
implementing AES and SM4 SBoxes in hardware.

Verification engineers::
Responsible for ensuring the correct implementation of the extension
in hardware.
No cryptography background is assumed.
We expect them to identify interesting test cases from the
specification. An understanding of their real-world usage will help with this.
We do not expect verification engineers in this sense to be experts
in entropy source design or certification, since this is a very
specialised area.
We do expect them however to identify all of the _architectural_
test cases around the entropy source interface.

These are by no means the only people concerned with the specification,
but they are the ones we considered most while writing it.

[[crypto_scalar_sail_specifications]]
==== Sail Specifications

RISC-V maintains a 
link:https://github.com/riscv/sail-riscv[formal model]
of the ISA specification,
implemented in the Sail ISA specification language
cite:[sail].
Note that _Sail_ refers to the specification language itself,
and that there is a _model of RISC-V_, written using Sail.
It is not correct to refer to "the Sail model".
This is ambiguous, given there are many models of different ISAs implemented
using Sail. We refer to the Sail implementation of RISC-V as
"the RISC-V Sail model".

The Cryptography extension uses inline Sail code snippets from the
actual model to give canonical descriptions of instruction
functionality.
Each instruction is accompanied by its expression in Sail, and includes
calls to supporting functions which are too verbose to include directly
in the specification.
This supporting code is listed in
<<crypto_scalar_appx_sail>>.
The 
link:https://github.com/rems-project/sail/blob/sail2/manual.pdf[Sail Manual]
is recommended reading in order to best understand the code snippets.

Note that this document contains only a subset of the formal model: refer to
the formal model Github
link:https://github.com/riscv/sail-riscv[repository]
for the complete model.

[[crypto_scalar_policies]]
==== Policies

In creating this proposal, we tried to adhere to the following
policies:

* Where there is a choice between:
  . supporting diverse implementation strategies for an algorithm
  or
  . supporting a single implementation style which is more performant /
     less expensive;
  the crypto extension will pick the more constrained but performant
  option.
  This fits a common pattern in other parts of the RISC-V specification,
  where recommended (but not required) instruction sequences for performing
  particular tasks are given as an example, such that both hardware and
  software implementers can optimise for only a single use-case.
  
* The extension will be designed to support _existing_ standardised
  cryptographic constructs well.
  It will not try to support proposed standards, or cryptographic
  constructs which exist only in academia.
  Cryptographic standards which are settled upon concurrently with or after
  the RISC-V cryptographic extension standardisation will be dealt with
  by future additions to, or versions of, the RISC-V cryptographic
  standard extension. It is anticipated that the NIST Lightweight
  Cryptography contest and the NIST Post-Quantum Cryptography contest
  may be dealt with this way, depending on timescales.
  
* Historically, there has been some discussion
  cite:[LSYRR:04]
  on how newly supported operations in general-purpose computing might
  enable new bases for cryptographic algorithms.
  The standard will not try to anticipate new useful low-level
  operations which _may_ be useful as building blocks for
  future cryptographic constructs.
  
* Regarding side-channel countermeasures:
  Where relevant, proposed instructions must aim to remove the
  possibility of any timing side-channels.
  For side-channels based on power or electro-magnetic (EM) measurements,
  the extension will not aim to support countermeasures which are
  implemented above the ISA abstraction layer.
  Recommendations will be given where relevant on how micro-architectures
  can implement instructions in a power/EM side-channel resistant way.

[[crypto_scalar_extensions]]
=== Extensions Overview

The group of extensions introduced by the Scalar Cryptography Instruction Set
Extension is listed here.

Detection of individual cryptography extensions uses the
unified software-based RISC-V discovery method.

[NOTE]
====
At the time of writing, these discovery mechanisms are still a work in
progress.
====

.A note on extension rationale
[NOTE, caption="SH"]
====
Specialist encryption and decryption instructions are separated into different
functional groups because some use cases (e.g., Galois/Counter
Mode in TLS 1.3) do not require decryption functionality.

The NIST and ShangMi algorithms suites are separated because their
usefulness is heavily dependent on the countries a device is expected to
operate in. NIST ciphers are a part of most standardised internet
protocols, while ShangMi ciphers are required for use in China.
====

[[zbkb,Zbkb]]
==== `Zbkb` - Bitmanip instructions for Cryptography

These are a subset of the Bitmanipulation Extension `Zbb` which are
particularly useful for Cryptography.

NOTE: Some of these instructions are defined in the first Bitmanip
ratification package, and some are not (
<<insns-pack,pack>>,
<<insns-packh,packh>>,
<<insns-packw,packw>>,
<<insns-brev8,brev8>>,
<<insns-zip,zip>>,
<<insns-unzip,unzip>>).
All of the instructions in <<zbkb>> have their complete specification included
in this document, including those _not_ present in the initial
Bitmanip ratification package.
This is to make the present specification complete as a standalone document.
Inevitably there might be small divergences between the Bitmanip and
Scalar Cryptography specification documents as they move at different
paces.
When this happens, assume that the Bitmanip specification has the
most up-to-date version of Bitmanip instructions.
This is an unfortunate but necessary stop-gap while Scalar Cryptography
and Bitmanip are being rapidly iterated on prior to public review.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; |  ror         | <<insns-ror>>
| &#10003; | &#10003; |  rol         | <<insns-rol>>
| &#10003; | &#10003; |  rori        | <<insns-rori>>
|          | &#10003; |  rorw        | <<insns-rorw>>
|          | &#10003; |  rolw        | <<insns-rolw>>
|          | &#10003; |  roriw       | <<insns-roriw>>
| &#10003; | &#10003; |  andn        | <<insns-andn>>
| &#10003; | &#10003; |  orn         | <<insns-orn>>
| &#10003; | &#10003; |  xnor        | <<insns-xnor>>
| &#10003; | &#10003; |  pack        | <<insns-pack>>
| &#10003; | &#10003; |  packh       | <<insns-packh>>
|          | &#10003; |  packw       | <<insns-packw>>
| &#10003; | &#10003; |  brev8       | <<insns-brev8>>
| &#10003; | &#10003; |  rev8        | <<insns-rev8>>
| &#10003; |          |  zip         | <<insns-zip>>
| &#10003; |          |  unzip       | <<insns-unzip>>
|===

[[zbkc,Zbkc]]
==== `Zbkc` - Carry-less multiply instructions

Constant time carry-less multiply for Galois/Counter Mode.
These are separated from the <<zbkb>> because they
have a considerable implementation overhead which cannot be amortised
across other instructions.

NOTE: These instructions are defined in the first Bitmanip
ratification package for the `Zbc` extension.
All of the instructions in <<zbkc>> have their complete specification included
in this document, including those _not_ present in the initial
Bitmanip ratification package.
This is to make the present specification complete as a standalone document.
Inevitably there might be small divergences between the Bitmanip and
Scalar Cryptography specification documents as they move at different
paces.
When this happens, assume that the Bitmanip specification has the
most up-to-date version of Bitmanip instructions.
This is an unfortunate but necessary stop-gap while Scalar Cryptography
and Bitmanip are being rapidly iterated on prior to public review.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; |  clmul       | <<insns-clmul>>
| &#10003; | &#10003; |  clmulh      | <<insns-clmulh>>
|===

[[zbkx,Zbkx]]
==== `Zbkx` - Crossbar permutation instructions

These instructions are useful for implementing SBoxes in constant time, and
potentially with DPA protections.
These are separated from the <<zbkb>> because they
have an implementation overhead which cannot be amortised
across other instructions.

NOTE: All of these instructions are missing from the first Bitmanip
ratification package.
Hence,  all of the instructions in <<zbkx>> have their complete specification
included in this document.
This is to make the present specification complete as a standalone document.
Inevitably there might be small divergences between the Bitmanip and
Scalar Cryptography specification documents as they move at different
paces.
When this happens, assume that the Bitmanip specification has the
most up-to-date version of Bitmanip instructions.
This is an unfortunate but necessary stop-gap while Scalar Cryptography
and Bitmanip are being rapidly iterated on prior to public review.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; |  xperm8      | <<insns-xperm8>>
| &#10003; | &#10003; |  xperm4      | <<insns-xperm4>>
|===

[[zknd,Zknd]]
==== `Zknd` - NIST Suite: AES Decryption

Instructions for accelerating the decryption and key-schedule functions of
the AES block cipher.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; |          | aes32dsi     | <<insns-aes32dsi>>
| &#10003; |          | aes32dsmi    | <<insns-aes32dsmi>>
|          | &#10003; | aes64ds      | <<insns-aes64ds>>
|          | &#10003; | aes64dsm     | <<insns-aes64dsm>>
|          | &#10003; | aes64im      | <<insns-aes64im>>
|          | &#10003; | aes64ks1i    | <<insns-aes64ks1i>>
|          | &#10003; | aes64ks2     | <<insns-aes64ks2>>
|===

NOTE: The <<insns-aes64ks1i>> and <<insns-aes64ks2>> instructions are
present in both the <<zknd>> and <<zkne>> extensions.

[[zkne,Zkne]]
==== `Zkne` - NIST Suite: AES Encryption

Instructions for accelerating the encryption and key-schedule functions of
the AES block cipher.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; |          | aes32esi     | <<insns-aes32esi>>
| &#10003; |          | aes32esmi    | <<insns-aes32esmi>>
|          | &#10003; | aes64es      | <<insns-aes64es>>
|          | &#10003; | aes64esm     | <<insns-aes64esm>>
|          | &#10003; | aes64ks1i    | <<insns-aes64ks1i>>
|          | &#10003; | aes64ks2     | <<insns-aes64ks2>>
|===

NOTE: The
<<insns-aes64ks1i,`aes64ks1i`>>
and
<<insns-aes64ks2,`aes64ks2`>>
instructions are present in both the <<zknd>> and <<zkne>> extensions.

[[zknh,Zknh]]
==== `Zknh` - NIST Suite: Hash Function Instructions

Instructions for accelerating the SHA2 family of cryptographic hash functions,
as specified in cite:[nist:fips:180:4].

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; | sha256sig0   | <<insns-sha256sig0>>
| &#10003; | &#10003; | sha256sig1   | <<insns-sha256sig1>>
| &#10003; | &#10003; | sha256sum0   | <<insns-sha256sum0>>
| &#10003; | &#10003; | sha256sum1   | <<insns-sha256sum1>>
| &#10003; |          | sha512sig0h  | <<insns-sha512sig0h>>
| &#10003; |          | sha512sig0l  | <<insns-sha512sig0l>>
| &#10003; |          | sha512sig1h  | <<insns-sha512sig1h>>
| &#10003; |          | sha512sig1l  | <<insns-sha512sig1l>>
| &#10003; |          | sha512sum0r  | <<insns-sha512sum0r>>
| &#10003; |          | sha512sum1r  | <<insns-sha512sum1r>>
|          | &#10003; | sha512sig0   | <<insns-sha512sig0>>
|          | &#10003; | sha512sig1   | <<insns-sha512sig1>>
|          | &#10003; | sha512sum0   | <<insns-sha512sum0>>
|          | &#10003; | sha512sum1   | <<insns-sha512sum1>>
|===

[[zksed,Zksed]]
==== `Zksed` - ShangMi Suite: SM4 Block Cipher Instructions

Instructions for accelerating the SM4 Block Cipher.
Note that unlike AES, this cipher uses the same core operation for
encryption and decryption, hence there is only one
extension for it.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; | sm4ed        | <<insns-sm4ed>>
| &#10003; | &#10003; | sm4ks        | <<insns-sm4ks>>
|===

[[zksh,Zksh]]
==== `Zksh` - ShangMi Suite: SM3 Hash Function Instructions

Instructions for accelerating the SM3 hash function.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; | sm3p0        | <<insns-sm3p0>>
| &#10003; | &#10003; | sm3p1        | <<insns-sm3p1>>
|===

[[zkr,Zkr]]
==== `Zkr` - Entropy Source Extension

The entropy source extension defines the `seed` CSR at address `0x015`. 
This CSR provides up to 16 physical `entropy` bits that can be used to
seed cryptographic random bit generators. 

See <<crypto_scalar_es>> for the normative specification and access control
notes. <<crypto_scalar_appx_es>> contains design rationale and further
recommendations to implementers.

[[zkn,Zkn]]
==== `Zkn` - NIST Algorithm Suite

This extension is shorthand for the following set of other extensions:

[%header,cols="^1,4"]
|===
|Included Extension
|Description

| <<zbkb>>  | Bitmanipulation instructions for cryptography.
| <<zbkc>>  | Carry-less multiply instructions.
| <<zbkx>>  | Cross-bar Permutation instructions.
| <<zkne>>  | AES encryption instructions.
| <<zknd>>  | AES decryption instructions.
| <<zknh>>  | SHA2 hash function instructions.
|===

A core which implements `Zkn` must implement all of the above extensions.

[[zks,Zks]]
==== `Zks` - ShangMi Algorithm Suite

This extension is shorthand for the following set of other extensions:

[%header,cols="^1,4"]
|===
|Included Extension
|Description

| <<zbkb>>  | Bitmanipulation instructions for cryptography.
| <<zbkc>>  | Carry-less multiply instructions.
| <<zbkx>>  | Cross-bar Permutation instructions.
| <<zksed>> | SM4 block cipher instructions.
| <<zksh>>  | SM3 hash function instructions.
|===

A core which implements `Zks` must implement all of the above extensions.

[[zk,Zk]]
==== `Zk` - Standard scalar cryptography extension

This extension is shorthand for the following set of other extensions:

[%header,cols="^1,4"]
|===
|Included Extension
|Description

| <<zkn>>  | NIST Algorithm suite extension.
| <<zkr>>  | Entropy Source extension.
| <<crypto_scalar_zkt,Zkt>>  | Data independent execution latency extension.
|===

A core which implements `Zk` must implement all of the above extensions.

==== `Zkt` - Data Independent Execution Latency

This extension allows CPU implementers to indicate to
cryptographic software developers that a subset of RISC-V instructions
are guaranteed to be implemented such that their execution latency
is independent of the data values they operate on.
A complete description of this extension is found in
<<crypto_scalar_zkt>>.

// ------------------------------------------------------------

[[crypto_scalar_insns, reftext="Scalar Cryptography Instructions"]]
=== Instructions

[#insns-aes32dsi, reftext="AES final round decrypt (RV32)"]
==== aes32dsi

Synopsis::
AES final round decryption instruction for RV32.

Mnemonic::
aes32dsi rd, rs1, rs2, bs

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x15},
{bits: 2, name: 'bs'},
]}
....

Description:: 
This instruction sources a single byte from `rs2` according to `bs`.
To this it applies the inverse AES SBox operation, and XOR's the result with
`rs1`.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (AES32DSI (bs,rs2,rs1,rd)) = {
  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */
  let si      : bits( 8) = (X(rs2)[31..0] >> shamt)[7..0]; /* SBox Input */
  let so      : bits(32) = 0x000000 @ aes_sbox_inv(si);
  let result  : bits(32) = X(rs1)[31..0] ^ rol32(so, unsigned(shamt));
  X(rd) = EXTS(result); RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknd>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes32dsmi, reftext="AES middle round decrypt (RV32)"]
==== aes32dsmi

Synopsis::
AES middle round decryption instruction for RV32.

Mnemonic::
aes32dsmi rd, rs1, rs2, bs

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x17},
{bits: 2, name: 'bs'},
]}
....

Description:: 
This instruction sources a single byte from `rs2` according to `bs`.
To this it applies the inverse AES SBox operation, and a partial inverse
MixColumn, before XOR'ing the result with `rs1`.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (AES32DSMI (bs,rs2,rs1,rd)) = {
  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */
  let si      : bits( 8) = (X(rs2)[31..0] >> shamt)[7..0]; /* SBox Input */
  let so      : bits( 8) = aes_sbox_inv(si);
  let mixed   : bits(32) = aes_mixcolumn_byte_inv(so);
  let result  : bits(32) = X(rs1)[31..0] ^ rol32(mixed, unsigned(shamt));
  X(rd) = EXTS(result); RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknd>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes32esi, reftext="AES final round encrypt (RV32)"]
==== aes32esi

Synopsis::
AES final round encryption instruction for RV32.

Mnemonic::
aes32esi rd, rs1, rs2, bs

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x11},
{bits: 2, name: 'bs'},
]}
....

Description:: 
This instruction sources a single byte from `rs2` according to `bs`.
To this it applies the forward AES SBox operation,
before XOR'ing the result with `rs1`.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (AES32ESI (bs,rs2,rs1,rd)) = {
  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */
  let si      : bits( 8) = (X(rs2)[31..0] >> shamt)[7..0]; /* SBox Input */
  let so      : bits(32) = 0x000000 @ aes_sbox_fwd(si);
  let result  : bits(32) = X(rs1)[31..0] ^ rol32(so, unsigned(shamt));
  X(rd) = EXTS(result); RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zkne>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes32esmi, reftext="AES middle round encrypt (RV32)"]
==== aes32esmi

Synopsis::
AES middle round encryption instruction for RV32.

Mnemonic::
aes32esmi rd, rs1, rs2, bs

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x13},
{bits: 2, name: 'bs'},
]}
....

Description:: 
This instruction sources a single byte from `rs2` according to `bs`.
To this it applies the forward AES SBox operation, and a partial forward
MixColumn, before XOR'ing the result with `rs1`.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (AES32ESMI (bs,rs2,rs1,rd)) = {
  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */
  let si      : bits( 8) = (X(rs2)[31..0] >> shamt)[7..0]; /* SBox Input */
  let so      : bits( 8) = aes_sbox_fwd(si);
  let mixed   : bits(32) = aes_mixcolumn_byte_fwd(so);
  let result  : bits(32) = X(rs1)[31..0] ^ rol32(mixed, unsigned(shamt));
  X(rd) = EXTS(result); RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zkne>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes64ds, reftext="AES decrypt final round (RV64)"]
==== aes64ds

Synopsis::
AES final round decryption instruction for RV64.

Mnemonic::
aes64ds rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1d},
{bits: 2, name: 0x0},
]}
....

Description:: 
Uses the two 64-bit source registers to represent the entire AES state,
and produces _half_ of the next round output, applying the Inverse ShiftRows
and SubBytes steps.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

.Note To Software Developers
[NOTE,caption="SH"]
====
The following code snippet shows the final round of the AES block decryption.
`t0` and `t1` hold the current round state.
`t2` and `t3` hold the next round state.

  aes64ds t2, t0, t1
  aes64ds t3, t1, t0

Note the reversed register order of the second instruction.
====

Operation::
[source,sail]
--
function clause execute (AES64DS(rs2, rs1, rd)) = {
  let sr : bits(64) = aes_rv64_shiftrows_inv(X(rs2)[63..0], X(rs1)[63..0]);
  let wd : bits(64) = sr[63..0];
  X(rd) = aes_apply_inv_sbox_to_each_byte(wd);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknd>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes64dsm, reftext="AES decrypt middle round (RV64)"]
==== aes64dsm

Synopsis::
AES middle round decryption instruction for RV64.

Mnemonic::
aes64dsm rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1f},
{bits: 2, name: 0x0},
]}
....

Description:: 
Uses the two 64-bit source registers to represent the entire AES state,
and produces _half_ of the next round output, applying the Inverse ShiftRows,
SubBytes and MixColumns steps.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

.Note To Software Developers
[NOTE,caption="SH"]
====
The following code snippet shows one middle round of the AES block decryption.
`t0` and `t1` hold the current round state.
`t2` and `t3` hold the next round state.

  aes64dsm t2, t0, t1
  aes64dsm t3, t1, t0

Note the reversed register order of the second instruction.
====

Operation::
[source,sail]
--
function clause execute (AES64DSM(rs2, rs1, rd)) = {
  let sr : bits(64) = aes_rv64_shiftrows_inv(X(rs2)[63..0], X(rs1)[63..0]);
  let wd : bits(64) = sr[63..0];
  let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd);
  X(rd)  = aes_mixcolumn_inv(sb[63..32]) @ aes_mixcolumn_inv(sb[31..0]);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknd>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes64es, reftext="AES encrypt final round instruction (RV64)"]
==== aes64es

Synopsis::
AES final round encryption instruction for RV64.

Mnemonic::
aes64es rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x19},
{bits: 2, name: 0x0},
]}
....

Description:: 
Uses the two 64-bit source registers to represent the entire AES state,
and produces _half_ of the next round output, applying the ShiftRows and
SubBytes steps.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

.Note To Software Developers
[NOTE,caption="SH"]
====
The following code snippet shows the final round of the AES block encryption.
`t0` and `t1` hold the current round state.
`t2` and `t3` hold the next round state.

  aes64es t2, t0, t1
  aes64es t3, t1, t0

Note the reversed register order of the second instruction.
====

Operation::
[source,sail]
--
function clause execute (AES64ES(rs2, rs1, rd)) = {
  let sr : bits(64) = aes_rv64_shiftrows_fwd(X(rs2)[63..0], X(rs1)[63..0]);
  let wd : bits(64) = sr[63..0];
  X(rd) = aes_apply_fwd_sbox_to_each_byte(wd);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zkne>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes64esm, reftext="AES encrypt middle round instruction (RV64)"]
==== aes64esm

Synopsis::
AES middle round encryption instruction for RV64.

Mnemonic::
aes64esm rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1b},
{bits: 2, name: 0x0},
]}
....

Description:: 
Uses the two 64-bit source registers to represent the entire AES state,
and produces _half_ of the next round output, applying the ShiftRows,
SubBytes and MixColumns steps.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

.Note To Software Developers
[NOTE,caption="SH"]
====
The following code snippet shows one middle round of the AES block encryption.
`t0` and `t1` hold the current round state.
`t2` and `t3` hold the next round state.

  aes64esm t2, t0, t1
  aes64esm t3, t1, t0

Note the reversed register order of the second instruction.
====

Operation::
[source,sail]
--
function clause execute (AES64ESM(rs2, rs1, rd)) = {
  let sr : bits(64) = aes_rv64_shiftrows_fwd(X(rs2)[63..0], X(rs1)[63..0]);
  let wd : bits(64) = sr[63..0];
  let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd);
  X(rd)  =  aes_mixcolumn_fwd(sb[63..32]) @ aes_mixcolumn_fwd(sb[31..0]);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zkne>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes64im, reftext="AES Decrypt KeySchedule MixColumns (RV64)"]
==== aes64im

Synopsis::
This instruction accelerates the inverse MixColumns step of the AES
Block Cipher, and is used to aid creation of the decryption KeySchedule.

Mnemonic::
aes64im rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x0},
{bits: 5, name: 0x18},
{bits: 2, name: 0x0},
]}
....

Description:: 
The instruction applies the inverse MixColumns
transformation to two columns of the state array, packed into a single
64-bit register.
It is used to create the inverse cipher KeySchedule, according to
the equivalent inverse cipher construction in
cite:[nist:fips:197] (Page 23, Section 5.3.5).
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (AES64IM(rs1, rd)) = {
  let w0 : bits(32) = aes_mixcolumn_inv(X(rs1)[31.. 0]);
  let w1 : bits(32) = aes_mixcolumn_inv(X(rs1)[63..32]);
  X(rd)  = w1 @ w0;
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknd>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes64ks1i, reftext="AES Key Schedule Instruction 1 (RV64)"]
==== aes64ks1i

Synopsis::
This instruction implements part of the KeySchedule operation for the
AES Block cipher involving the SBox operation.

Mnemonic::
aes64ks1i rd, rs1, rnum

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 4, name: 'rnum'},
{bits: 1, name: 0x1},
{bits: 5, name: 0x18},
{bits: 2, name: 0},
]}
....

Description:: 
This instruction implements the rotation, SubBytes and Round Constant
addition steps of the AES block cipher Key Schedule.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.
Note that `rnum` must be in the range `0x0..0xA`.
The values `0xB..0xF` are reserved.

Operation::
[source,sail]
--
function clause execute (AES64KS1I(rnum, rs1, rd)) = {
  if(unsigned(rnum) > 10) then {
    handle_illegal();  RETIRE_SUCCESS
  } else {
    let tmp1 : bits(32) = X(rs1)[63..32];
    let rc   : bits(32) = aes_decode_rcon(rnum); /* round number -> round constant */
    let tmp2 : bits(32) = if (rnum ==0xA) then tmp1 else ror32(tmp1, 8);
    let tmp3 : bits(32) = aes_subword_fwd(tmp2);
    let result : bits(64) = (tmp3 ^ rc) @ (tmp3 ^ rc);
    X(rd) = EXTZ(result);
    RETIRE_SUCCESS
  }
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zkne>> (RV64)
| v1.0.0
| Frozen
| <<zknd>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-aes64ks2, reftext="AES Key Schedule Instruction 2 (RV64)"]
==== aes64ks2

Synopsis::
This instruction implements part of the KeySchedule operation for the
AES Block cipher.

Mnemonic::
aes64ks2 rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1f},
{bits: 2, name: 0x1},
]}
....

Description:: 
This instruction implements the additional XOR'ing of key words as
part of the AES block cipher Key Schedule.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (AES64KS2(rs2, rs1, rd)) = {
  let w0 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0];
  let w1 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0] ^ X(rs2)[63..32];
  X(rd)  = w1 @ w0;
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zkne>> (RV64)
| v1.0.0
| Frozen
| <<zknd>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-andn,reftext="AND with inverted operand"]
==== andn

Synopsis::
AND with inverted operand

Mnemonic::
andn _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x7, attr: ['ANDN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['ANDN'] },
]}
....

Description:: 
This instruction performs the bitwise logical AND operation between _rs1_ and the bitwise inversion of _rs2_.

Operation::
[source,sail]
--
X(rd) = X(rs1) & ~X(rs2);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-clmul,reftext="Carry-less multiply (low-part)"]
==== clmul

Synopsis::
Carry-less multiply (low-part)

Mnemonic::
clmul _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CLMUL'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

Description::
clmul produces the lower half of the 2·XLEN carry-less product.

Operation::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 0 to (xlen - 1) by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val << i);
            else output;
}

X[rd] = output
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbc (<<#zbc>>)
|1.0.0
|Frozen

|Zbkc (<<#zbkc>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-clmulh,reftext="Carry-less multiply (high-part)"]
==== clmulh

Synopsis::
Carry-less multiply (high-part)

Mnemonic::
clmulh _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x3, attr: ['CLMULH'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

Description::
clmulh produces the upper half of the 2·XLEN carry-less product.

Operation::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 1 to xlen by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val >> (xlen - i));
            else output;
}

X[rd] = output
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbc (<<#zbc>>)
|1.0.0
|Frozen

|Zbkc (<<#zbkc>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-orn,reftext="OR with inverted operand"]
==== orn

Synopsis::
OR with inverted operand

Mnemonic::
orn _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['ORN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['ORN'] },
]}
....

Description:: 
This instruction performs the bitwise logical OR operation between _rs1_ and the bitwise inversion of _rs2_.

Operation::
[source,sail]
--
X(rd) = X(rs1) | ~X(rs2);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-pack,reftext="Pack low halves of registers"]
==== pack

Synopsis::
Pack the low halves of _rs1_ and _rs2_ into _rd_.

Mnemonic::
pack _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    {bits:  7, name: 0x33, attr: ['OP'] },
    {bits: 5, name: 'rd'},
    {bits: 3, name: 0x4, attr:['PACK']},
    {bits: 5, name: 'rs1'},
    {bits: 5, name: 'rs2'},
    {bits: 7, name: 0x4, attr:['PACK']},
]}
....

Description:: 
The pack instruction packs the XLEN/2-bit lower halves of _rs1_ and _rs2_ into
_rd_, with _rs1_ in the lower half and _rs2_ in the upper half.

Operation::
[source,sail]
--
let lo_half : bits(xlen/2) = X(rs1)[xlen/2-1..0];
let hi_half : bits(xlen/2) = X(rs2)[xlen/2-1..0];
X(rd) = EXTZ(hi_half @ lo_half);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-packh,reftext="Pack low bytes of registers"]
==== packh

Synopsis::
Pack the low bytes of _rs1_ and _rs2_ into _rd_.

Mnemonic::
packh _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    {bits:  7, name: 0x33, attr: ['OP'] },
    {bits: 5, name: 'rd'},
    {bits: 3, name: 0x7, attr: ['PACKH']},
    {bits: 5, name: 'rs1'},
    {bits: 5, name: 'rs2'},
    {bits: 7, name: 0x4, attr: ['PACKH']},
]}
....

Description:: 
And the packh instruction packs the least-significant bytes of
_rs1_ and _rs2_ into the 16 least-significant bits of _rd_,
zero extending the rest of _rd_.

Operation::
[source,sail]
--
let lo_half : bits(8) = X(rs1)[7..0];
let hi_half : bits(8) = X(rs2)[7..0];
X(rd) = EXTZ(hi_half @ lo_half);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-packw,reftext="Pack low 16-bits of registers (RV64)"]
==== packw

Synopsis::
Pack the low 16-bits of _rs1_ and _rs2_ into _rd_ on RV64.

Mnemonic::
packw _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0xe},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x4},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 7, name: 0x4},
]}
....

Description:: 
This instruction packs the low 16 bits of
_rs1_ and _rs2_ into the 32 least-significant bits of _rd_,
sign extending the 32-bit result to the rest of _rd_.
This instruction only exists on RV64 based systems.

Operation::
[source,sail]
--
let lo_half : bits(16) = X(rs1)[15..0];
let hi_half : bits(16) = X(rs2)[15..0];
X(rd) = EXTS(hi_half @ lo_half);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-rev8,reftext="Byte-reverse register"]
==== rev8

Synopsis::
Byte-reverse register

Mnemonic::
rev8 _rd_, _rs_

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x698 }
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x6b8 }
]}
....

Description:: 
This instruction reverses the order of the bytes in _rs_.

Operation::
[source,sail]
--
let input = X(rs);
let output : xlenbits = 0;
let j = xlen - 1;

foreach (i from 0 to (xlen - 8) by 8) {
   output[i..(i + 7)] = input[(j - 7)..j];
   j = j - 8;
}

X[rd] = output
--

.Note
[NOTE, caption="A" ]
===============================================================
The *rev8* mnemonic corresponds to different instruction encodings in RV32 and RV64.
===============================================================

.Software Hint
[NOTE, caption="SH" ]
===============================================================
The byte-reverse operation is only available for the full register
width.  To emulate word-sized and halfword-sized byte-reversal,
perform a `rev8 rd,rs` followed by a `srai rd,rd,K`, where K is
XLEN-32 and XLEN-16, respectively.
===============================================================

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-rol,reftext="Rotate left (Register)"]
==== rol

Synopsis::
Rotate Left (Register)

Mnemonic::
rol _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['ROL']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROL'] },
]}
....

Description::
This instruction performs a rotate left of _rs1_ by the amount in least-significant log2(XLEN) bits of _rs2_.

Operation::
[source,sail]
--
let shamt = if   xlen == 32
            then X(rs2)[4..0]
            else X(rs2)[5..0];
let result = (X(rs1) << shamt) | (X(rs1) >> (xlen - shamt));

X(rd) = result;
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-rolw,reftext="Rotate Left Word (Register)"]
==== rolw

Synopsis::
Rotate Left Word (Register)

Mnemonic::
rolw _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['ROLW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROLW'] },
]}
....

Description::
This instruction performs a rotate left on the least-significant word of  _rs1_ by the amount in least-significant 5 bits of _rs2_.
The resulting word value is sign-extended by copying bit 31 to all of the more-significant bits. 

Operation::
[source,sail]
--
let rs1 = EXTZ(X(rs1)[31..0])
let shamt = X(rs2)[4..0];
let result = (rs1 << shamt) | (rs1 >> (32 - shamt));
X(rd) = EXTS(result[31..0]);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-ror, reftext="Rotate right (Register)"]
==== ror

Synopsis::
Rotate Right

Mnemonic::
ror _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['ROR']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROR'] },
]}
....

Description::
This instruction performs a rotate right of _rs1_ by the amount in least-significant log2(XLEN) bits of _rs2_.

Operation::
[source,sail]
--
let shamt = if   xlen == 32
            then X(rs2)[4..0]
            else X(rs2)[5..0];
let result = (X(rs1) >> shamt) | (X(rs1) << (xlen - shamt));

X(rd) = result;
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-rori,reftext="Rotate right (Immediate)"]
==== rori

Synopsis::
Rotate Right (Immediate)

Mnemonic::
rori _rd_, _rs1_, _shamt_

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORI']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x30, attr: ['RORI'] },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORI']},
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x18, attr: ['RORI'] },
]}
....

Description:: 
This instruction performs a rotate right of _rs1_ by the amount in the least-significant log2(XLEN) bits of _shamt_.
For RV32, the encodings corresponding to shamt[5]=1 are reserved.

Operation::
[source,sail]
--
let shamt = if   xlen == 32
            then shamt[4..0]
            else shamt[5..0];
let result = (X(rs1) >> shamt) | (X(rs1) << (xlen - shamt));

X(rd) = result;
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-roriw,reftext="Rotate right Word (Immediate)"]
==== roriw

Synopsis::
Rotate Right Word by Immediate

Mnemonic::
roriw _rd_, _rs1_, _shamt_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORIW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x30, attr: ['RORIW'] },
]}
....

Description:: 
This instruction performs a rotate right on the least-significant word
of _rs1_ by the amount in the least-significant log2(XLEN) bits of
_shamt_.
The resulting word value is sign-extended by copying bit 31 to all of
the more-significant bits.


Operation::
[source,sail]
--
let rs1_data = EXTZ(X(rs1)[31..0];
let result = (rs1_data >> shamt) | (rs1_data << (32 - shamt));
X(rd) = EXTS(result[31..0]);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-rorw,reftext="Rotate right Word (Register)"]
==== rorw

Synopsis::
Rotate Right Word (Register)

Mnemonic::
rorw _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['RORW'] },
]}
....

Description:: 
This instruction performs a rotate right on the least-significant word of  _rs1_ by the amount in least-significant 5 bits of _rs2_.
The resultant word is sign-extended by copying bit 31 to all of the more-significant bits.

Operation::
[source,sail]
--
let rs1 = EXTZ(X(rs1)[31..0])
let shamt = X(rs2)[4..0];
let result = (rs1 >> shamt) | (rs1 << (32 - shamt));
X(rd) = EXTS(result);
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-sha256sig0, reftext="SHA2-256 Sigma0 instruction"]
==== sha256sig0

Synopsis::
Implements the Sigma0 transformation function as used in
the SHA2-256 hash function cite:[nist:fips:180:4] (Section 4.1.2).

Mnemonic::
sha256sig0 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x2},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for both RV32 and RV64 base architectures.
For RV32, the entire `XLEN` source register is operated on.
For RV64, the low `32` bits of the source register are operated on, and the
result sign extended to `XLEN` bits.
Though named for SHA2-256, the instruction works for both the
SHA2-224 and SHA2-256 parameterisations as described in
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA256SIG0(rs1,rd)) = {
  let inb    : bits(32) = X(rs1)[31..0];
  let result : bits(32) = ror32(inb,  7) ^ ror32(inb, 18) ^ (inb >>  3);
  X(rd)      = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>>
| v1.0.0
| Frozen
| <<zkn>>
| v1.0.0
| Frozen
| <<zk>>
| v1.0.0
| Frozen
|===

<<<

[#insns-sha256sig1, reftext="SHA2-256 Sigma1 instruction"]
==== sha256sig1

Synopsis::
Implements the Sigma1 transformation function as used in
the SHA2-256 hash function cite:[nist:fips:180:4] (Section 4.1.2).

Mnemonic::
sha256sig1 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x3},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for both RV32 and RV64 base architectures.
For RV32, the entire `XLEN` source register is operated on.
For RV64, the low `32` bits of the source register are operated on, and the
result sign extended to `XLEN` bits.
Though named for SHA2-256, the instruction works for both the
SHA2-224 and SHA2-256 parameterisations as described in
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA256SIG1(rs1,rd)) = {
  let inb    : bits(32) = X(rs1)[31..0];
  let result : bits(32) = ror32(inb, 17) ^ ror32(inb, 19) ^ (inb >> 10);
  X(rd)      = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>>
| v1.0.0
| Frozen
| <<zkn>>
| v1.0.0
| Frozen
| <<zk>>
| v1.0.0
| Frozen
|===

<<<

[#insns-sha256sum0, reftext="SHA2-256 Sum0 instruction"]
==== sha256sum0

Synopsis::
Implements the Sum0 transformation function as used in
the SHA2-256 hash function cite:[nist:fips:180:4] (Section 4.1.2).

Mnemonic::
sha256sum0 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x0},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for both RV32 and RV64 base architectures.
For RV32, the entire `XLEN` source register is operated on.
For RV64, the low `32` bits of the source register are operated on, and the
result sign extended to `XLEN` bits.
Though named for SHA2-256, the instruction works for both the
SHA2-224 and SHA2-256 parameterisations as described in
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA256SUM0(rs1,rd)) = {
  let inb    : bits(32) = X(rs1)[31..0];
  let result : bits(32) = ror32(inb,  2) ^ ror32(inb, 13) ^ ror32(inb, 22);
  X(rd)      = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>>
| v1.0.0
| Frozen
| <<zkn>>
| v1.0.0
| Frozen
| <<zk>>
| v1.0.0
| Frozen
|===

<<<

[#insns-sha256sum1, reftext="SHA2-256 Sum1 instruction"]
==== sha256sum1

Synopsis::
Implements the Sum1 transformation function as used in
the SHA2-256 hash function cite:[nist:fips:180:4] (Section 4.1.2).

Mnemonic::
sha256sum1 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x1},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for both RV32 and RV64 base architectures.
For RV32, the entire `XLEN` source register is operated on.
For RV64, the low `32` bits of the source register are operated on, and the
result sign extended to `XLEN` bits.
Though named for SHA2-256, the instruction works for both the
SHA2-224 and SHA2-256 parameterisations as described in
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA256SUM1(rs1,rd)) = {
  let inb    : bits(32) = X(rs1)[31..0];
  let result : bits(32) = ror32(inb,  6) ^ ror32(inb, 11) ^ ror32(inb, 25);
  X(rd)      = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>>
| v1.0.0
| Frozen
| <<zkn>>
| v1.0.0
| Frozen
| <<zk>>
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sig0h, reftext="SHA2-512 Sigma0 high (RV32)"]
==== sha512sig0h

Synopsis::
Implements the _high half_ of the Sigma0 transformation, as
used in the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sig0h rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0xe},
{bits: 2, name: 0x1},
]}
....

Description:: 
This instruction is implemented on RV32 only.
Used to compute the Sigma0 transform of the SHA2-512 hash function
in conjunction with the <<insns-sha512sig0l,`sha512sig0l`>> instruction.
The transform is a 64-bit to 64-bit function, so the input and output
are each represented by two 32-bit registers.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

[TIP]
.Note to software developers
====
The entire Sigma0 transform for SHA2-512 may be computed on RV32
using the following instruction sequence:

 sha512sig0l    t0, a0, a1 
 sha512sig0h    t1, a1, a0 

====

Operation::
[source,sail]
--
function clause execute (SHA512SIG0H(rs2, rs1, rd)) = {
  X(rd) = EXTS((X(rs1) >>  1) ^ (X(rs1) >>  7) ^ (X(rs1) >>  8) ^
               (X(rs2) << 31)                  ^ (X(rs2) << 24) );
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sig0l, reftext="SHA2-512 Sigma0 low (RV32)"]
==== sha512sig0l

Synopsis::
Implements the _low half_ of the Sigma0 transformation, as
used in the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sig0l rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0xa},
{bits: 2, name: 0x1},
]}
....

Description:: 
This instruction is implemented on RV32 only.
Used to compute the Sigma0 transform of the SHA2-512 hash function
in conjunction with the <<insns-sha512sig0h,`sha512sig0h`>> instruction.
The transform is a 64-bit to 64-bit function, so the input and output
are each represented by two 32-bit registers.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

[TIP]
.Note to software developers
====
The entire Sigma0 transform for SHA2-512 may be computed on RV32
using the following instruction sequence:

 sha512sig0l    t0, a0, a1 
 sha512sig0h    t1, a1, a0 

====

Operation::
[source,sail]
--
function clause execute (SHA512SIG0L(rs2, rs1, rd)) = {
  X(rd) = EXTS((X(rs1) >>  1) ^ (X(rs1) >>  7) ^ (X(rs1) >>  8) ^
               (X(rs2) << 31) ^ (X(rs2) << 25) ^ (X(rs2) << 24) );
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sig1h, reftext="SHA2-512 Sigma1 high (RV32)"]
==== sha512sig1h

Synopsis::
Implements the _high half_ of the Sigma1 transformation, as
used in the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sig1h rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0xf},
{bits: 2, name: 0x1},
]}
....

Description:: 
This instruction is implemented on RV32 only.
Used to compute the Sigma1 transform of the SHA2-512 hash function
in conjunction with the <<insns-sha512sig1l,`sha512sig1l`>> instruction.
The transform is a 64-bit to 64-bit function, so the input and output
are each represented by two 32-bit registers.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

[TIP]
.Note to software developers
====
The entire Sigma1 transform for SHA2-512 may be computed on RV32
using the following instruction sequence:

 sha512sig1l    t0, a0, a1 
 sha512sig1h    t1, a1, a0

====

Operation::
[source,sail]
--
function clause execute (SHA512SIG1H(rs2, rs1, rd)) = {
  X(rd) = EXTS((X(rs1) <<  3) ^ (X(rs1) >>  6) ^ (X(rs1) >> 19) ^
               (X(rs2) >> 29)                  ^ (X(rs2) << 13) );
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sig1l, reftext="SHA2-512 Sigma1 low (RV32)"]
==== sha512sig1l

Synopsis::
Implements the _low half_ of the Sigma1 transformation, as
used in the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sig1l rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0xb},
{bits: 2, name: 0x1},
]}
....

Description:: 
This instruction is implemented on RV32 only.
Used to compute the Sigma1 transform of the SHA2-512 hash function
in conjunction with the <<insns-sha512sig1h,`sha512sig1h`>> instruction.
The transform is a 64-bit to 64-bit function, so the input and output
are each represented by two 32-bit registers.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

[TIP]
.Note to software developers
====
The entire Sigma1 transform for SHA2-512 may be computed on RV32
using the following instruction sequence:

 sha512sig1l    t0, a0, a1 
 sha512sig1h    t1, a1, a0

====

Operation::
[source,sail]
--
function clause execute (SHA512SIG1L(rs2, rs1, rd)) = {
  X(rd) = EXTS((X(rs1) <<  3) ^ (X(rs1) >>  6) ^ (X(rs1) >> 19) ^
               (X(rs2) >> 29) ^ (X(rs2) << 26) ^ (X(rs2) << 13) );
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sum0r, reftext="SHA2-512 Sum0 (RV32)"]
==== sha512sum0r

Synopsis::
Implements the Sum0 transformation, as
used in the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sum0r rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x8},
{bits: 2, name: 0x1},
]}
....

Description:: 
This instruction is implemented on RV32 only.
Used to compute the Sum0 transform of the SHA2-512 hash function.
The transform is a 64-bit to 64-bit function, so the input and output
is represented by two 32-bit registers.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

[TIP]
.Note to software developers
====
The entire Sum0 transform for SHA2-512 may be computed on RV32
using the following instruction sequence:

 sha512sum0r    t0, a0, a1 
 sha512sum0r    t1, a1, a0 

Note the reversed source register ordering.
====

Operation::
[source,sail]
--
function clause execute (SHA512SUM0R(rs2, rs1, rd)) = {
  X(rd) = EXTS((X(rs1) << 25) ^ (X(rs1) << 30) ^ (X(rs1) >> 28) ^
               (X(rs2) >>  7) ^ (X(rs2) >>  2) ^ (X(rs2) <<  4) );
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sum1r, reftext="SHA2-512 Sum1 (RV32)"]
==== sha512sum1r

Synopsis::
Implements the Sum1 transformation, as
used in the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sum1r rd, rs1, rs2

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x9},
{bits: 2, name: 0x1},
]}
....

Description:: 
This instruction is implemented on RV32 only.
Used to compute the Sum1 transform of the SHA2-512 hash function.
The transform is a 64-bit to 64-bit function, so the input and output
is represented by two 32-bit registers.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

[TIP]
.Note to software developers
====
The entire Sum1 transform for SHA2-512 may be computed on RV32
using the following instruction sequence:

 sha512sum1r    t0, a0, a1 
 sha512sum1r    t1, a1, a0 

Note the reversed source register ordering.
====

Operation::
[source,sail]
--
function clause execute (SHA512SUM1R(rs2, rs1, rd)) = {
  X(rd) = EXTS((X(rs1) << 23) ^ (X(rs1) >> 14) ^ (X(rs1) >> 18) ^
               (X(rs2) >>  9) ^ (X(rs2) << 18) ^ (X(rs2) << 14) );
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV32)
| v1.0.0
| Frozen
| <<zkn>> (RV32)
| v1.0.0
| Frozen
| <<zk>> (RV32)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sig0, reftext="SHA2-512 Sigma0 instruction (RV64)"]
==== sha512sig0

Synopsis::
Implements the Sigma0 transformation function as used in
the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sig0 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x6},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for the RV64 base architecture.
It implements the Sigma0 transform of the SHA2-512 hash function.
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA512SIG0(rs1, rd)) = {
  X(rd) = ror64(X(rs1),  1) ^ ror64(X(rs1),  8) ^ (X(rs1) >> 7);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sig1, reftext="SHA2-512 Sigma1 instruction (RV64)"]
==== sha512sig1

Synopsis::
Implements the Sigma1 transformation function as used in
the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sig1 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x7},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for the RV64 base architecture.
It implements the Sigma1 transform of the SHA2-512 hash function.
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA512SIG1(rs1, rd)) = {
  X(rd) = ror64(X(rs1), 19) ^ ror64(X(rs1), 61) ^ (X(rs1) >> 6);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sum0, reftext="SHA2-512 Sum0 instruction (RV64)"]
==== sha512sum0

Synopsis::
Implements the Sum0 transformation function as used in
the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sum0 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x4},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for the RV64 base architecture.
It implements the Sum0 transform of the SHA2-512 hash function.
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA512SUM0(rs1, rd)) = {
  X(rd) = ror64(X(rs1), 28) ^ ror64(X(rs1), 34) ^ ror64(X(rs1) ,39);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-sha512sum1, reftext="SHA2-512 Sum1 instruction (RV64)"]
==== sha512sum1

Synopsis::
Implements the Sum1 transformation function as used in
the SHA2-512 hash function cite:[nist:fips:180:4] (Section 4.1.3).

Mnemonic::
sha512sum1 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x5},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for the RV64 base architecture.
It implements the Sum1 transform of the SHA2-512 hash function.
cite:[nist:fips:180:4].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SHA512SUM1(rs1, rd)) = {
  X(rd) = ror64(X(rs1), 14) ^ ror64(X(rs1), 18) ^ ror64(X(rs1) ,41);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zknh>> (RV64)
| v1.0.0
| Frozen
| <<zkn>> (RV64)
| v1.0.0
| Frozen
| <<zk>> (RV64)
| v1.0.0
| Frozen
|===

<<<

[#insns-sm3p0, reftext="SM3 P0 transform"]
==== sm3p0

Synopsis::
Implements the _P0_ transformation function as used in
the SM3 hash function cite:[gbt:sm3,iso:sm3].

Mnemonic::
sm3p0 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x8},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for the RV32 and RV64 base architectures.
It implements the _P0_ transform of the SM3 hash function cite:[gbt:sm3,iso:sm3].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

.Supporting Material
[NOTE]
====
This instruction is based on work done in cite:[MJS:LWSHA:20].
====

Operation::
[source,sail]
--
function clause execute (SM3P0(rs1, rd)) = {
  let r1     : bits(32) = X(rs1)[31..0];
  let result : bits(32) =  r1 ^ rol32(r1,  9) ^ rol32(r1, 17);
  X(rd) = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zksh>>
| v1.0.0
| Frozen
| <<zks>>
| v1.0.0
| Frozen
|===

<<<

[#insns-sm3p1, reftext="SM3 P1 transform"]
==== sm3p1

Synopsis::
Implements the _P1_ transformation function as used in
the SM3 hash function cite:[gbt:sm3,iso:sm3].

Mnemonic::
sm3p1 rd, rs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x9},
{bits: 5, name: 0x8},
{bits: 2, name: 0x0},
]}
....

Description:: 
This instruction is supported for the RV32 and RV64 base architectures.
It implements the _P1_ transform of the SM3 hash function cite:[gbt:sm3,iso:sm3].
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

.Supporting Material
[NOTE]
====
This instruction is based on work done in cite:[MJS:LWSHA:20].
====

Operation::
[source,sail]
--
function clause execute (SM3P1(rs1, rd)) = {
  let r1     : bits(32) = X(rs1)[31..0];
  let result : bits(32) =  r1 ^ rol32(r1, 15) ^ rol32(r1, 23);
  X(rd) = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zksh>>
| v1.0.0
| Frozen
| <<zks>>
| v1.0.0
| Frozen
|===

<<<

[#insns-sm4ed, reftext="SM4 Encrypt/Decrypt Instruction"]
==== sm4ed

Synopsis::
Accelerates the block encrypt/decrypt operation of the SM4 block cipher
cite:[gbt:sm4, iso:sm4].

Mnemonic::
sm4ed rd, rs1, rs2, bs

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x18},
{bits: 2, name: 'bs'},
]}
....

Description:: 
Implements a T-tables in hardware style approach to accelerating the
SM4 round function.
A byte is extracted from `rs2` based on `bs`, to which the SBox and
linear layer transforms are applied, before the result is XOR'd with
`rs1` and written back to `rd`.
This instruction exists on RV32 and RV64 base architectures.
On RV64, the 32-bit result is sign extended to XLEN bits.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SM4ED (bs,rs2,rs1,rd)) = {
  let shamt : bits(5)  = bs @ 0b000; /* shamt = bs*8 */
  let sb_in : bits(8)  = (X(rs2)[31..0] >> shamt)[7..0];
  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);
  let y     : bits(32) = x ^ (x               <<  8) ^ ( x               <<  2) ^
                             (x               << 18) ^ ((x & 0x0000003F) << 26) ^
                             ((x & 0x000000C0) << 10);
  let z     : bits(32) = rol32(y, unsigned(shamt));
  let result: bits(32) = z ^ X(rs1)[31..0];
  X(rd)                = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zksed>>
| v1.0.0
| Frozen
| <<zks>>
| v1.0.0
| Frozen
|===

<<<

[#insns-sm4ks, reftext="SM4 Key Schedule Instruction"]
==== sm4ks

Synopsis::
Accelerates the Key Schedule operation of the SM4 block cipher
cite:[gbt:sm4, iso:sm4].

Mnemonic::
sm4ks rd, rs1, rs2, bs

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1a},
{bits: 2, name: 'bs'},
]}
....

Description:: 
Implements a T-tables in hardware style approach to accelerating the
SM4 Key Schedule.
A byte is extracted from `rs2` based on `bs`, to which the SBox and
linear layer transforms are applied, before the result is XOR'd with
`rs1` and written back to `rd`.
This instruction exists on RV32 and RV64 base architectures.
On RV64, the 32-bit result is sign extended to XLEN bits.
This instruction must _always_ be implemented such that its execution
latency does not depend on the data being operated on.

Operation::
[source,sail]
--
function clause execute (SM4KS (bs,rs2,rs1,rd)) = {
  let shamt : bits(5)  = (bs @ 0b000); /* shamt = bs*8 */
  let sb_in : bits(8)  = (X(rs2)[31..0] >> shamt)[7..0];
  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);
  let y     : bits(32) = x ^ ((x & 0x00000007) << 29) ^ ((x & 0x000000FE) <<  7) ^
                             ((x & 0x00000001) << 23) ^ ((x & 0x000000F8) << 13) ;
  let z     : bits(32) = rol32(y, unsigned(shamt));
  let result: bits(32) = z ^ X(rs1)[31..0];
  X(rd) = EXTS(result);
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zksed>>
| v1.0.0
| Frozen
| <<zks>>
| v1.0.0
| Frozen
|===

<<<

[#insns-unzip,reftext="Bit deinterleave"]
==== unzip

Synopsis::
Implements the inverse of the zip instruction.

Mnemonic::
unzip _rd_, _rs_

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0x4},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x5},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x1f},
{bits: 7, name: 0x4},
]}
....

Description:: 
This instruction gathers bits from the high and low halves of the source
word into odd/even bit positions in the destination word.
It is the inverse of the <<insns-zip,zip>> instruction.
This instruction is available only on RV32.

Operation::
[source,sail]
--
foreach (i from 0 to xlen/2-1) {
  X(rd)[i] = X(rs1)[2*i]
  X(rd)[i+xlen/2] = X(rs1)[2*i+1]
}
--

.Software Hint
[NOTE, caption="SH" ]
===============================================================
This instruction is useful for implementing the SHA3 cryptographic
hash function on a 32-bit architecture, as it implements the
bit-interleaving operation used to speed up the 64-bit rotations
directly.
===============================================================

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbkb (<<#zbkb>>) (RV32)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-xnor,reftext="Exclusive NOR"]
==== xnor

Synopsis::
Exclusive NOR

Mnemonic::
xnor _rd_, _rs1_, _rs2_

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['XNOR']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['XNOR'] },
]}
....

Description:: 
This instruction performs the bit-wise exclusive-NOR operation on _rs1_ and _rs2_.

Operation::
[source,sail]
--
X(rd) = ~(X(rs1) ^ X(rs2));
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|v1.0.0
|Frozen

|Zbkb (<<#zbkb>>)
|v1.0.0-rc4
|Frozen
|===

<<<

[#insns-zip,reftext="Bit interleave"]
==== zip

Synopsis::
Gather odd and even bits of the source word into upper/lower halves of the
destination.

Mnemonic::
zip _rd_, _rs_

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0x4},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x1e},
{bits: 7, name: 0x4},
]}
....

Description:: 
This instruction scatters all of the odd and even bits of a source word into
the high and low halves of a destination word.
It is the inverse of the <<insns-unzip,unzip>> instruction.
This instruction is available only on RV32.

Operation::
[source,sail]
--
foreach (i from 0 to xlen/2-1) {
  X(rd)[2*i] = X(rs1)[i]
  X(rd)[2*i+1] = X(rs1)[i+xlen/2]
}
--

.Software Hint
[NOTE, caption="SH" ]
===============================================================
This instruction is useful for implementing the SHA3 cryptographic
hash function on a 32-bit architecture, as it implements the
bit-interleaving operation used to speed up the 64-bit rotations
directly.
===============================================================

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbkb (<<#zbkb>>) (RV32)
|v1.0.0-rc4
|Frozen
|===

<<<

[[crypto_scalar_es]]
=== Entropy Source

The `seed` CSR provides an interface to a NIST SP 800-90B cite:[TuBaKe:18] 
or BSI AIS-31 cite:[KiSc11] compliant physical Entropy Source (ES).

An entropy source, by itself, is not a cryptographically secure Random
Bit Generator (RBG), but can be used to build standard (and nonstandard)
RBGs of many types with the help of symmetric cryptography. Expected usage
is to condition (typically with SHA-2/3) the output from an entropy source and
use it to seed a cryptographically secure Deterministic Random Bit Generator
(DRBG) such as AES-based `CTR_DRBG` cite:[BaKe15].
The combination of an Entropy Source, Conditioning, and a DRBG can be used
to create random bits securely cite:[BaKeRo:21].
See <<crypto_scalar_appx_es>> for a non-normative description of a
certification and self-certification procedures, design rationale, and more
detailed suggestions on how the entropy source output can be used.

[[crypto_scalar_seed_csr]]
==== The `seed` CSR

`seed` is an unprivileged CSR located at address `0x015`. 
The 32-bit contents of `seed` are as follows:

[%autowidth.stretch,cols="^,^,<",options="header",]
|=======================================================================
|Bits |Name |Description

|`31:30` |`OPST` |Status: `BIST` (00), `WAIT` (01), `ES16` (10), `DEAD`
(11).

|`29:24` |_reserved_ |For future use by the RISC-V specification.

|`23:16` |_custom_ |Designated for custom and experimental use.

|`15: 0` |`entropy` |16 bits of randomness, only when `OPST=ES16`.
|=======================================================================

The `seed` CSR must be accessed with a read-write instruction. A read-only
instruction such as `CSRRS/CSRRC` with `rs1=x0` or `CSRRSI/CSRRCI` with
`uimm=0` will raise an illegal instruction exception.
The write value (in `rs1` or `uimm`) must be ignored by implementations.
The purpose of the write is to signal polling and flushing.

The instruction `csrrw rd, seed, x0` can be used for fetching seed status
and entropy values. It is available on both RV32 and RV64 base architectures
and will zero-extend the 32-bit word to XLEN bits.

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x73, attr: "SYSTEM"},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1, attr: "CSRRW"},
{bits: 5, name: 0x0, attr: "x0"},
{bits: 12, name: 0x15, attr: "seed = 0x015"},
]}
....

The `seed` CSR is also access controlled by execution mode, and attempted
read or write access will raise an illegal instruction exception outside M mode
unless access is explicitly granted. See <<crypto_scalar_es_access>> for
more details.

The status bits `seed[31:30]` = `OPST` may be `ES16` (10),
indicating successful polling, or one of three entropy polling failure
statuses `BIST` (00), `WAIT` (01), or `DEAD` (11), discussed below.

Each returned `seed[15:0]` = `entropy` value represents unique randomness
when `OPST`=`ES16` (`seed[31:30]` = `10`), even if its numerical value is
the same as that of a previously polled `entropy` value. The implementation
requirements of `entropy` bits are defined in <<crypto_scalar_es_req>>.
When `OPST` is not `ES16`, `entropy` must be set to 0.
An implementation may safely set reserved and custom bits to zeros.

For security reasons, the interface guarantees that secret `entropy`
words are not made available multiple times. Hence polling (reading) must
also have the side effect of clearing (wipe-on-read) the `entropy` contents and
changing the state to `WAIT` (unless there is `entropy`
immediately available for `ES16`). Other states (`BIST`, `WAIT`, and `DEAD`)
may be unaffected by polling.

The Status Bits returned in `seed[31:30]`=`OPST`:

* `00` - `BIST`
indicates that Built-In Self-Test "on-demand" (BIST) testing is being
performed. If `OPST` returns temporarily to `BIST` from any other
state, this signals a non-fatal self-test alarm,
which is non-actionable, apart from being logged.
Such a `BIST` alarm must be latched until polled at least once to enable
software to record its occurrence.

* `01` - `WAIT`
means that a sufficient amount of entropy is not yet available. This
is not an error condition and may (in fact) be more frequent than ES16
since physical entropy sources often have low bandwidth.

* `10` - `ES16`
indicates success; the low bits `seed[15:0]` will have 16 bits of
randomness (`entropy`), which is guaranteed to meet certain minimum entropy
requirements, regardless of implementation.

* `11` - `DEAD`
is an unrecoverable self-test error. This may indicate a hardware
fault, a security issue, or (extremely rarely) a type-1 statistical
false positive in the continuous testing procedures. In case of a fatal
failure, an immediate lockdown may also be an appropriate response in
dedicated security devices.

**Example.** `0x8000ABCD` is a valid `ES16` status output, with `0xABCD`
being the `entropy` value. `0xFFFFFFFF` is an invalid output (`DEAD`) with
no `entropy` value.

[[crypto_scalar_es_state,reftext="Entropy Source State Transition Diagram"]]
====
image::es_state.svg[title="Entropy Source state transition diagram.", align="center",scaledwidth=40%]
Normally the operational state alternates between WAIT
(no data) and ES16, which means that 16 bits of randomness (`entropy`)
have been polled. BIST (Built-in Self-Test) only occurs after reset
or to signal a non-fatal self-test alarm (if reached after WAIT or
ES16). DEAD is an unrecoverable error state.
====

[[crypto_scalar_es_req]]
==== Entropy Source Requirements

The output `entropy` (`seed[15:0]` in ES16 state) is not necessarily
fully conditioned randomness due to hardware and energy limitations
of smaller, low-powered implementations. However, minimum requirements are
defined. The main requirement is that 2-to-1 cryptographic post-processing
in 256-bit input blocks will yield 128-bit "full entropy" output blocks.
Entropy source users may make this conservative assumption but are not
prohibited from using more than twice the number of seed bits relative
to the desired resulting entropy.

An implementation of the entropy source should meet at least one of the
following requirements sets in order to be considered a secure and
safe design:

*	<<crypto_scalar_es_req_90b>>: A physical entropy source meeting
	NIST SP 800-90B cite:[TuBaKe:18] criteria with evaluated min-entropy
	of 192 bits for each 256 output bits (min-entropy rate 0.75).

*	<<crypto_scalar_es_req_ptg2>>: A physical entropy source meeting the
	AIS-31 PTG.2 cite:[KiSc11] criteria, implying average Shannon entropy
	rate 0.997. The source must also meet the NIST 800-90B 
	min-entropy rate 192/256 = 0.75.
	
*	<<crypto_scalar_es_req_virt>>: A virtual entropy source is a DRBG
	seeded from a physical entropy source. It must have at least a
	256-bit (Post-Quantum Category 5) internal security level.

All implementations must signal initialization, test mode, and health
alarms as required by respective standards. This may require the implementer
to add non-standard (custom) test interfaces in a secure and safe manner,
an example of which is described in <<crypto_scalar_es_getnoise>>


[[crypto_scalar_es_req_90b]]
===== NIST SP 800-90B / FIPS 140-3 Requirements

All NIST SP 800-90B cite:[TuBaKe:18] required components and health test 
mechanisms must be implemented. 

The entropy requirement is satisfied if 128 bits of _full entropy_ can be
obtained from each 256-bit (16*16 -bit) successful, but possibly
non-consecutive `entropy` (ES16) output sequence using a vetted conditioning
algorithm such as a cryptographic hash (See Section 3.1.5.1.1, SP 800-90B
cite:[TuBaKe:18]). In practice, a min-entropy rate of 0.75 or larger is
required for this. 

Note that 128 bits of estimated input min-entropy does not yield 128 bits of 
conditioned, full entropy in SP 800-90B/C evaluation. Instead, the
implication is that every 256-bit sequence should have min-entropy of at
least 128+64 = 192 bits, as discussed in SP 800-90C cite:[BaKeRo:21];
the likelihood of successfully "guessing" an individual 256-bit output
sequence should not be higher than 2^-192^ even with (almost)
unconstrained amount of entropy source data and computational power.

Rather than attempting to define all the mathematical and architectural
properties that the entropy source must satisfy, we define that the physical
entropy source be strong and robust enough to pass the equivalent of
NIST SP 800-90 evaluation and certification for full entropy when
conditioned cryptographically in ratio 2:1 with 128-bit output blocks.

Even though the requirement is defined in terms of 128-bit full entropy
blocks, we recommend 256-bit security. This can be accomplished by using
at least 512 `entropy` bits to initialize a DRBG that has 256-bit security.

[[crypto_scalar_es_req_ptg2]]
===== BSI AIS-31 PTG.2 / Common Criteria Requirements

For alternative Common Criteria certification (or self-certification), 
AIS 31 PTG.2 class cite:[KiSc11] (Sect. 4.3.) required hardware components
and mechanisms must be implemented.
In addition to AIS-31 PTG.2 randomness requirements (Shannon entropy rate of
0.997 as evaluated in that standard), the overall min-entropy requirement of
remains, as discussed in <<crypto_scalar_es_req_90b>>. Note that 800-90B
min-entropy can be significantly lower than AIS-31 Shannon entropy. These
two metrics should not be equated or confused with each other.


[[crypto_scalar_es_req_virt]]
===== Virtual Sources: Security Requirement

NOTE: A virtual source is not an ISA compliance requirement. It is defined
for the benefit of the RISC-V security ecosystem so that virtual systems
may have a consistent level of security.

A virtual source is not a physical entropy source but provides
additional protection against covert channels, depletion attacks, and host
identification in operating environments that can not be entirely trusted
with direct access to a hardware resource. Despite limited trust,
implementors should try to guarantee that even such environments have
sufficient entropy available for secure cryptographic operations.

A virtual source traps access to the `seed` CSR, emulates it, or
otherwise implements it, possibly without direct access to a physical entropy
source. The output can be cryptographically secure pseudorandomness
instead of real entropy, but must have at least 256-bit security, as defined
below. A virtual source is intended especially for guest operating
systems, sandboxes, emulators, and similar use cases.

As a technical definition, a random-distinguishing attack against
the output should require computational resources comparable or greater
than those required for exhaustive key search on a secure block cipher
with a 256-bit key (e.g., AES 256). This applies to both classical
and quantum computing models, but only classical information flows.
The virtual source security requirement maps to Post-Quantum Security
Category 5 cite:[NI16].

Any implementation of the `seed` CSR that limits the security
strength shall not reduce it to less than 256 bits. If the security
level is under 256 bits, then the interface must not be available.

A virtual entropy source does not need to implement `WAIT` or `BIST` states.
It should fail (`DEAD`) if the host DRBG or entropy source fails and
there is insufficient seeding material for the host DRBG.


[[crypto_scalar_es_access]]
==== Access Control to `seed`

The `seed` CSR is by default only available in M mode, but can be made
available to other modes via the `mseccfg.sseed` and `mseccfg.useed`
access control bits. `sseed` is bit `9` of and `useed` is
bit `8` of the `mseccfg` CSR.
Without the corresponding access control bit set to 1, any attempted
access to `seed` from U, S, or HS modes will raise an illegal instruction
exception. 

VS and VU modes are present in systems with Hypervisor (H) extension
implemented. If desired, a hypervisor can emulate accesses to the seed CSR
from a virtual machine. Attempted access to `seed` from virtual modes
VS and VU always raises an exception; a read-only instruction causes an
illegal instruction exception, while a read-write instruction (that can
potentially be emulated) causes a virtual instruction exception only if
`mseccfg.sseed=1`. Note that `mseccfg.useed` has no effect on the exception
type for either VS or VU modes. 

.Entropy Source Access Control.

[cols="1,1,1,7",options="header",]
|=======================================================================
|Mode | `sseed` | `useed` | Description

| M
| `*`
| `*`
| The `seed` CSR is always available in machine mode as normal (with a
CSR read-write instruction.) Attempted read without a write raises an
illegal instruction exception regardless of mode and access control bits.

| U
| `*`
| `0`
| Any `seed` CSR access raises an illegal instruction exception.

| U
| `*`
| `1`
| The `seed` CSR is accessible as normal. No exception is raised for read-write.

| S/HS
| `0`
| `*`
| Any `seed` CSR access raises an illegal instruction exception.


| S/HS
| `1`
| `*`
| The `seed` CSR is accessible as normal. No exception is raised for read-write.

| VS/VU
| `0`
| `*`
| Any `seed` CSR access raises an illegal instruction exception.

| VS/VU
| `1`
| `*`
| A read-write `seed` access raises a virtual instruction exception,
while other access conditions raise an illegal instruction exception.

|=======================================================================


Systems should implement carefully considered access control policies from
lower privilege modes to physical entropy sources. The system can trap
attempted access to `seed` and feed a less privileged client
_virtual entropy source_ data (<<crypto_scalar_es_req_virt>>) instead of
invoking an SP 800-90B  (<<crypto_scalar_es_req_90b>>) or PTG.2 
(<<crypto_scalar_es_req_ptg2>>) _physical entropy source_. Emulated `seed`
data generation is made with an appropriately seeded, secure software DRBG.
See  <<crypto_scalar_appx_es_access>> for security considerations related 
to direct access to entropy sources.

Implementations may implement `mseccfg` such that `[s,u]seed` is a read-only
constant value `0`. Software may discover if access to the `seed` CSR can be
enabled in U and S mode by writing a `1` to `[s,u]seed` and reading back
the result.

If S or U mode is not implemented, then the corresponding `[s,u]seed`
bits of `mseccfg` must be hardwired to zero.
The `[s,u]seed` bits must have a defined reset value. The system
must not allow them to be in an undefined state after a reset.
`mseccfg` exists if `Zkr` is implemented, or if it is required by other
processor features. If `Zkr` is _not_ implemented, the `[s,u]seed` bits must
be hardwired to zero.

[[crypto_scalar_zkt]]

=== Data Independent Execution Latency Subset: Zkt

The Zkt extension attests that the machine has data-independent execution
time for a safe subset of instructions. This property is commonly called
_"constant-time"_ although should not be taken with that literal meaning.

All currently proposed cryptographic instructions (scalar K extension) are on
this list, together with a set of relevant supporting instructions from
I, M, C, and B extensions.


.Note to software developers
[NOTE,caption="SH"]
====
Failure to prevent leakage of sensitive parameters via the direct
timing channel is considered a serious security vulnerability and will
typically result in a CERT CVE security advisory.
====

==== Scope and Goal

An "ISA contract" is made between a programmer and the RISC-V implementation
that Zkt instructions do not leak information about processed secret data
(plaintext, keying information, or other "sensitive security parameters" --
FIPS 140-3 term) through differences in execution latency. Zkt does _not_
define a set of instructions available in the core; it just restricts the
behaviour of certain instructions if those are implemented.

Currently, the scope of this document is within scalar RV32/RV64 processors.
Vector cryptography instructions (and appropriate vector support instructions)
will be added later, as will other security-related functions that wish
to assert leakage-free execution latency properties.

Loads, stores, conditional branches are excluded, along with a set of
instructions that are rarely necessary to process secret data. Also excluded
are instructions for which workarounds exist in standard cryptographic
middleware due to the limitations of other ISA processors.

The stated goal is that OpenSSL, BoringSSL (Android), the Linux Kernel,
and similar trusted software will not have directly observable
timing side channels when compiled and running on a Zkt-enabled RISC-V target.
The Zkt extension explicitly states many of the common latency assumptions
made by cryptography developers.

Vendors do not have to implement all of the list's instructions to be Zkt
compliant; however, if they claim to have Zkt and implement any of the listed instructions, it must have data-independent latency. 

For example, many simple RV32I and RV64I cores (without Multiply, Compressed, 
Bitmanip, or Cryptographic extensions) are technically compliant with Zkt. 
A constant-time AES can be implemented on them using "bit-slice" techniques,
but it will be excruciatingly slow when compared to implementation with AES
instructions. There are no guarantees that even a bit-sliced cipher
implementation (largely based on boolean logic instructions) is secure on a
core without Zkt attestation.

Out-of-order implementations adhering to Zkt are still free to fuse, crack,
change or even ignore sequences of instructions, so long as the optimisations
are applied deterministically, and not based on operand data.
The guiding principle should be that no information about the data being
operated on should be leaked based on the execution latency.

[NOTE]
====
It is left to future extensions or other techniques to tackle the problem
of data-independent execution in implementations which advanced out-of-order
capabilities which use value prediction, or which are otherwise data-dependent.
====

.Note to software developers
[WARNING,caption="SH"]
====
Programming techniques can only mitigate leakage directly caused by
arithmetic, caches, and branches. Other ISAs have had micro-architectural
issues such as Spectre, Meltdown, Speculative Store Bypass, Rogue System
Register Read, Lazy FP State Restore, Bounds Check Bypass Store, TLBleed,
and L1TF/Foreshadow, etc. See e.g.
link:https://github.com/nsacyber/Hardware-and-Firmware-Security-Guidance[NSA Hardware and Firmware Security Guidance]

It is not within the remit of this proposal to mitigate these
_micro-architectural_ leakages.
====

==== Background

* Timing attacks are much more powerful than was realised before the 2010s,
which has led to a significant mitigation effort in current cryptographic
code-bases.
* Cryptography developers use static and dynamic security testing tools
to trace the handling of secret information and detect occasions where it
influences a branch or is used for a table lookup.
* Architectural testing for Zkt can be pragmatic and semi-formal;
_security by design_ against basic timing attacks can usually be achieved via
conscious implementation (of relevant iterative multi-cycle instructions or
instructions composed of micro-ops) in way that avoids data-dependent latency.
* Laboratory testing may utilize statistical timing attack leakage analysis
techniques such as those described in ISO/IEC 17825 cite:[IS16].
* Binary executables should not contain secrets in the instruction encodings
(Kerckhoffs's principle), so instruction timing may leak information about
immediates, ordering of input registers, etc. There may be an exception to this
in systems where a binary loader modifies the executable for purposes of
relocation -- and it is desirable to keep the execution location (PC) secret.
This is why instructions such as LUI, AUIPC, and ADDI are on the list.
* The rules used by audit tools are relatively simple to understand.
Very briefly; we call the plaintext, secret keys, expanded keys, nonces,
and other such variables "secrets". A secret variable (arithmetically)
modifying any other variable/register turns that into a secret too.
If a secret ends up in address calculation affecting a load or store, that
is a violation. If a secret affects a branch's condition, that is also a
violation. A secret variable location or register becomes a non-secret via
specific zeroization/sanitisation or by being declared ciphertext 
(or otherwise no-longer-secret information). In essence, secrets can only
"touch" instructions on the Zkt list while they are secrets.

==== Specific Instruction Rationale

* HINT instruction forms (typically encodings with `rd=x0`) are excluded from
the data-independent time requirement. 
* Floating point (F, D, Q, L extensions) are currently excluded from the
constant-time requirement as they have very few applications in standardised
cryptography. We may consider adding floating point add, sub, multiply as a
constant time requirement for some floating point extension in case a specific
algorithm (such as the PQC Signature algorithm Falcon) becomes critical.
*  Cryptographers typically assume division to be variable-time (while
multiplication is constant time) and implement their Montgomery reduction
routines with that assumption.
* Zicsr, Zifencei are excluded.
* Some instructions are on the list simply because we see no harm in
including them in testing scope.


==== Programming Information

For background information on secure programming "models", see:

* Thomas Pornin: _"Why Constant-Time Crypto?"_ (A great introduction to timing assumptions.) https://www.bearssl.org/constanttime.html
* Jean-Philippe Aumasson: _"Guidelines for low-level cryptography software."_
(A list of recommendations.) https://github.com/veorq/cryptocoding
* Peter Schwabe: _"Timing Attacks and Countermeasures."_
(Lecture slides -- nice references.)
https://summerschool-croatia.cs.ru.nl/2016/slides/PeterSchwabe.pdf
* Adam Langley: _"ctgrind."_ (This is from 2010 but is still relevant.)
https://www.imperialviolet.org/2010/04/01/ctgrind.html
* Kris Kwiatkowski: _"Constant-time code verification with Memory Sanitizer."_
https://www.amongbytes.com/post/20210709-testing-constant-time/
* For early examples of timing attack vulnerabilities, see
https://www.kb.cert.org/vuls/id/997481 and related academic papers.


==== Zkt listings

The following instructions are included in the `Zkt` subset
They are listed here grouped by their original parent extension.

.Note to implementers
[NOTE, caption="SH"]
====
You do not need to implement all of these instructions to implement `Zkt`.
Rather, every one of these instructions that the core does implement must
adhere to the requirements of `Zkt`.
====

=====	RVI (Base Instruction Set)

Only basic arithmetic and `slt*` (for carry computations) are included.
The data-independent timing requirement does not apply to HINT instruction
encoding forms of these instructions.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; | lui   _rd_, _imm_        |  <<insns-lui>>
| &#10003; | &#10003; | auipc _rd_, _imm_        |  <<insns-auipc>>
| &#10003; | &#10003; | addi  _rd_, _rs1_, _imm_ |  <<insns-addi>>
| &#10003; | &#10003; | slti  _rd_, _rs1_, _imm_ |  <<insns-slti>>
| &#10003; | &#10003; | sltiu _rd_, _rs1_, _imm_ |  <<insns-sltiu>>
| &#10003; | &#10003; | xori  _rd_, _rs1_, _imm_ |  <<insns-xori>>
| &#10003; | &#10003; | ori   _rd_, _rs1_, _imm_ |  <<insns-ori>>
| &#10003; | &#10003; | andi  _rd_, _rs1_, _imm_ |  <<insns-andi>>
| &#10003; | &#10003; | slli  _rd_, _rs1_, _imm_ |  <<insns-slli>>
| &#10003; | &#10003; | srli  _rd_, _rs1_, _imm_ |  <<insns-srli>>
| &#10003; | &#10003; | srai  _rd_, _rs1_, _imm_ |  <<insns-srai>>
| &#10003; | &#10003; | add   _rd_, _rs1_, _rs2_ |  <<insns-add>>
| &#10003; | &#10003; | sub   _rd_, _rs1_, _rs2_ |  <<insns-sub>>
| &#10003; | &#10003; | sll   _rd_, _rs1_, _rs2_ |  <<insns-sll>>
| &#10003; | &#10003; | slt   _rd_, _rs1_, _rs2_ |  <<insns-slt>>
| &#10003; | &#10003; | sltu  _rd_, _rs1_, _rs2_ |  <<insns-sltu>>
| &#10003; | &#10003; | xor   _rd_, _rs1_, _rs2_ |  <<insns-xor>>
| &#10003; | &#10003; | srl   _rd_, _rs1_, _rs2_ |  <<insns-srl>>
| &#10003; | &#10003; | sra   _rd_, _rs1_, _rs2_ |  <<insns-sra>>
| &#10003; | &#10003; | or    _rd_, _rs1_, _rs2_ |  <<insns-or>>
| &#10003; | &#10003; | and   _rd_, _rs1_, _rs2_ |  <<insns-and>>
|          | &#10003; | addiw _rd_, _rs1_, _imm_ |  <<insns-addiw>>
|          | &#10003; | slliw _rd_, _rs1_, _imm_ |  <<insns-slliw>>
|          | &#10003; | srliw _rd_, _rs1_, _imm_ |  <<insns-srliw>>
|          | &#10003; | sraiw _rd_, _rs1_, _imm_ |  <<insns-sraiw>>
|          | &#10003; | addw  _rd_, _rs1_, _rs2_ |  <<insns-addw>>
|          | &#10003; | subw  _rd_, _rs1_, _rs2_ |  <<insns-subw>>
|          | &#10003; | sllw  _rd_, _rs1_, _rs2_ |  <<insns-sllw>>
|          | &#10003; | srlw  _rd_, _rs1_, _rs2_ |  <<insns-srlw>>
|          | &#10003; | sraw  _rd_, _rs1_, _rs2_ |  <<insns-sraw>>
|===

=====	RVM (Multiply)

Multiplication is included; division and remaindering excluded.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; | mul    _rd_, _rs1_, _rs2_ | <<insns-mul>>
| &#10003; | &#10003; | mulh   _rd_, _rs1_, _rs2_ | <<insns-mulh>>
| &#10003; | &#10003; | mulhsu _rd_, _rs1_, _rs2_ | <<insns-mulhsu>>
| &#10003; | &#10003; | mulhu  _rd_, _rs1_, _rs2_ | <<insns-mulhu>>
|          | &#10003; | mulw   _rd_, _rs1_, _rs2_ | <<insns-mulw>>
|===

=====	RVC (Compressed)

Same criteria as in RVI. Organised by quadrants.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; | c.nop      | <<insns-c_nop>>
| &#10003; | &#10003; | c.addi     | <<insns-c_addi>>
|          | &#10003; | c.addiw    | <<insns-c_addiw>>
| &#10003; | &#10003; | c.lui      | <<insns-c_lui>>
| &#10003; | &#10003; | c.srli     | <<insns-c_srli>>
| &#10003; | &#10003; | c.srai     | <<insns-c_srai>>
| &#10003; | &#10003; | c.andi     | <<insns-c_andi>>
| &#10003; | &#10003; | c.sub      | <<insns-c_sub>>
| &#10003; | &#10003; | c.xor      | <<insns-c_xor>>
| &#10003; | &#10003; | c.or       | <<insns-c_or>>
| &#10003; | &#10003; | c.and      | <<insns-c_and>>
|          | &#10003; | c.subw     | <<insns-c_subw>>
|          | &#10003; | c.addw     | <<insns-c_addw>>
| &#10003; | &#10003; | c.slli     | <<insns-c_slli>>
| &#10003; | &#10003; | c.mv       | <<insns-c_mv>>
| &#10003; | &#10003; | c.add      | <<insns-c_add>>
|===

=====	RVK (Scalar Cryptography)

All K-specific instructions are included.
Additionally, `seed` CSR latency should be independent of `ES16` state output
`entropy` bits, as that is a sensitive security parameter.
See <<crypto_scalar_appx_es_access>>.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; |          | aes32dsi     | <<insns-aes32dsi>>
| &#10003; |          | aes32dsmi    | <<insns-aes32dsmi>>
| &#10003; |          | aes32esi     | <<insns-aes32esi>>
| &#10003; |          | aes32esmi    | <<insns-aes32esmi>>
|          | &#10003; | aes64ds      | <<insns-aes64ds>>
|          | &#10003; | aes64dsm     | <<insns-aes64dsm>>
|          | &#10003; | aes64es      | <<insns-aes64es>>
|          | &#10003; | aes64esm     | <<insns-aes64esm>>
|          | &#10003; | aes64im      | <<insns-aes64im>>
|          | &#10003; | aes64ks1i    | <<insns-aes64ks1i>>
|          | &#10003; | aes64ks2     | <<insns-aes64ks2>>
| &#10003; | &#10003; | sha256sig0   | <<insns-sha256sig0>>
| &#10003; | &#10003; | sha256sig1   | <<insns-sha256sig1>>
| &#10003; | &#10003; | sha256sum0   | <<insns-sha256sum0>>
| &#10003; | &#10003; | sha256sum1   | <<insns-sha256sum1>>
| &#10003; |          | sha512sig0h  | <<insns-sha512sig0h>>
| &#10003; |          | sha512sig0l  | <<insns-sha512sig0l>>
| &#10003; |          | sha512sig1h  | <<insns-sha512sig1h>>
| &#10003; |          | sha512sig1l  | <<insns-sha512sig1l>>
| &#10003; |          | sha512sum0r  | <<insns-sha512sum0r>>
| &#10003; |          | sha512sum1r  | <<insns-sha512sum1r>>
|          | &#10003; | sha512sig0   | <<insns-sha512sig0>>
|          | &#10003; | sha512sig1   | <<insns-sha512sig1>>
|          | &#10003; | sha512sum0   | <<insns-sha512sum0>>
|          | &#10003; | sha512sum1   | <<insns-sha512sum1>>
| &#10003; | &#10003; | sm3p0        | <<insns-sm3p0>>
| &#10003; | &#10003; | sm3p1        | <<insns-sm3p1>>
| &#10003; | &#10003; | sm4ed        | <<insns-sm4ed>>
| &#10003; | &#10003; | sm4ks        | <<insns-sm4ks>>
|===


=====	RVB (Bitmanip)

The <<zbkb>>, <<zbkx>> and <<zbkx>> extensions are included in their entirety.

.Note to implementers
[NOTE,caption="SH"]
====
Recall that `rev`, `zip` and `unzip` are pseudo-instructions representing
specific instances of `grevi`, `shfli` and `unshfli` respectively.
====

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

| &#10003; | &#10003; |  clmul       | <<insns-clmul>>
| &#10003; | &#10003; |  clmulh      | <<insns-clmulh>>
| &#10003; | &#10003; |  xperm4      | <<insns-xperm4>>
| &#10003; | &#10003; |  xperm8      | <<insns-xperm8>>
| &#10003; | &#10003; |  ror         | <<insns-ror>>
| &#10003; | &#10003; |  rol         | <<insns-rol>>
| &#10003; | &#10003; |  rori        | <<insns-rori>>
|          | &#10003; |  rorw        | <<insns-rorw>>
|          | &#10003; |  rolw        | <<insns-rolw>>
|          | &#10003; |  roriw       | <<insns-roriw>>
| &#10003; | &#10003; |  andn        | <<insns-andn>>
| &#10003; | &#10003; |  orn         | <<insns-orn>>
| &#10003; | &#10003; |  xnor        | <<insns-xnor>>
| &#10003; | &#10003; |  pack        | <<insns-pack>>
| &#10003; | &#10003; |  packh       | <<insns-packh>>
|          | &#10003; |  packw       | <<insns-packw>>
| &#10003; | &#10003; |  brev8       | <<insns-brev8>>
| &#10003; | &#10003; |  rev8        | <<insns-rev8>>
| &#10003; |          |  zip         | <<insns-zip>>
| &#10003; |          |  unzip       | <<insns-unzip>>
|===

[[crypto_scalar_appx_rationale]]
=== Instruction Rationale

This section contains various rationale, design notes and usage
recommendations for the instructions in the scalar cryptography
extension. It also tries to record how the designs of instructions were
derived, or where they were contributed from.

==== AES Instructions

The 32-bit instructions were derived from work in cite:[MJS:LWAES:20] and
contributed to the RISC-V cryptography extension.
The 64-bit instructions were developed collaboratively by task group
members on our mailing list.

Supporting material, including rationale and a design space exploration
for all of the AES instructions in the specification can be found in the paper
_"link:https://doi.org/10.46586/tches.v2021.i1.109-136[The design of scalar AES Instruction Set Extensions for RISC-V]"_ cite:[MNPSW:20].


==== SHA2 Instructions

These instructions were developed based on academic
work at the University of Bristol as part of the XCrypto project
cite:[MPP:19], and contributed to the RISC-V cryptography extension.

The RV32 SHA2-512 instructions were based on this work, and developed
in cite:[MJS:LWSHA:20], before being contributed in the same way.

==== SM3 and SM4 Instructions

The SM4 instructions were derived from work in cite:[MJS:LWAES:20], and
are hence very similar to the RV32 AES instructions.

The SM3 instructions were inspired by the SHA2 instructions, and
based on development work done in cite:[MJS:LWSHA:20], before being
contributed to the RISC-V cryptography extension.

[[crypto_scalar_zkb]]
==== Bitmanip Instructions for Cryptography

Many of the primitive operations used in symmetric key cryptography
and cryptographic hash functions are well supported by the
RISC-V Bitmanip cite:[riscv:bitmanip:repo] extensions.

NOTE: This section repeats much of the information in
<<zbkb>>,
<<zbkc>>
and
<<zbkx>>,
but includes more rationale.

We proposed that the scalar cryptographic extension _reuse_ a
subset of the instructions from the Bitmanip extensions `Zb[abc]` directly.
Specifically, this would mean that
a core implementing
_either_
the scalar cryptographic extensions,
_or_
the `Zb[abc]`,
_or_
both,
would be required to implement these instructions.

===== Rotations

----
RV32, RV64:                         RV64 only:
    ror    rd, rs1, rs2                 rorw   rd, rs1, rs2
    rol    rd, rs1, rs2                 rolw   rd, rs1, rs2
    rori   rd, rs1, imm                 roriw  rd, rs1, imm
----

See cite:[riscv:bitmanip:draft] (Section 3.1.1) for details of
these instructions.

.Notes to software developers
[NOTE,caption="SH"]
====
Standard bitwise rotation is a primitive operation in many block ciphers
and hash functions; it features particularly in the ARX (Add, Rotate, Xor)
class of block ciphers and stream ciphers.

* Algorithms making use of 32-bit rotations:
  SHA256, AES (Shift Rows), ChaCha20, SM3.
* Algorithms making use of 64-bit rotations:
  SHA512, SHA3.
====

===== Bit & Byte Permutations

----
RV32:
    brev8   rd, rs1 // grevi rd, rs1,  7 - Reverse bits in bytes
    rev8    rd, rs1 // grevi rd, rs1, 24 - Reverse bytes in 32-bit word

RV64:
    brev8   rd, rs1 // grevi rd, rs1,  7 - Reverse bits in bytes
    rev8    rd, rs1 // grevi rd, rs1, 56 - Reverse bytes in 64-bit word
----

The scalar cryptography extension provides the following instructions for
manipulating the bit and byte endianness of data.
They are all parameterisations of the Generalised Reverse with Immediate
(`grevi` instruction.
The scalar cryptography extension requires _only_ the above instances
of `grevi` be implemented, which can be invoked via their pseudo-ops.

The full specification of the `grevi` instruction is available in
cite:[riscv:bitmanip:draft] (Section 2.2.2).

.Notes to software developers
[NOTE,caption="SH"]
====
Reversing bytes in words is very common in cryptography when setting a
standard endianness for input and output data.
Bit reversal within bytes is used for implementing the GHASH component
of Galois/Counter Mode (GCM) cite:[nist:gcm].
====

----
RV32:
    zip     rd, rs1 // shfli   rd, rs1, 15 - Bit interleave
    unzip   rd, rs1 // unshfli rd, rs1, 15 - Bit de-interleave
----

The `zip` and `unzip` pseudo-ops are specific instances of
the more general `shfli` and `unshfli` instructions.
The scalar cryptography extension requires _only_ the above instances
of `[un]shfli` be implemented, which can be invoked via their
pseudo-ops.
Only RV32 implementations require these instructions.

The full specification of the `shfli` instruction is available in
cite:[riscv:bitmanip:draft] (Section 2.2.3).

.Notes to software developers
[NOTE,caption="SH"]
====
These instructions perform a bit-interleave (or de-interleave) operation, and
are useful for implementing the 64-bit rotations in the
SHA3 cite:[nist:fips:202] algorithm on
a 32-bit architecture.
On RV64, the relevant operations in SHA3 can be done natively using
rotation instructions, so `zip` and `unzip` are not required.
====

===== Carry-less Multiply

----
RV32, RV64:
    clmul  rd, rs1, rs2
    clmulh rd, rs1, rs2
----

See cite:[riscv:bitmanip:draft] (Section 2.6) for details of
this instruction.
See <<crypto_scalar_zkt>> for additional implementation
requirements for these instructions, related to data independent
execution latency.

.Notes to software developers
[NOTE,caption="SH"]
====
As is mentioned there, obvious cryptographic use-cases for carry-less
multiply are for Galois Counter Mode (GCM) block cipher operations.
GCM is recommended by NIST as a block cipher mode of operation
cite:[nist:gcm], and is the only _required_ mode for the TLS 1.3
protocol.
====

===== Logic With Negate

----
RV32, RV64:
    andn rd, rs1, rs2
     orn rd, rs1, rs2
    xnor rd, rs1, rs2
----

See cite:[riscv:bitmanip:draft] (Section 2.1.3) for details of
these instructions.
These instructions are useful inside hash functions, block ciphers and
for implementing software based side-channel countermeasures like masking.
The `andn` instruction is also useful for constant time word-select
in systems without the ternary Bitmanip `cmov` instruction.

.Notes to software developers
[NOTE,caption="SH"]
====
In the context of Cryptography, these instructions are useful for:
SHA3/Keccak Chi step,
Bit-sliced function implementations,
Software based power/EM side-channel countermeasures based on masking.
====

===== Packing

----
RV32, RV64:                         RV64: 
    pack   rd, rs1, rs2                 packw  rd, rs1, rs2
    packh  rd, rs1, rs2
----

See cite:[riscv:bitmanip:draft] (Section 2.1.4) for details of
these instructions.

.Notes to software developers
[NOTE,caption="SH"]
====
The `pack*` instructions are
useful for re-arranging halfwords within words, and
generally getting data into the right shape prior to applying transforms.
This is particularly useful for cryptographic algorithms which pass inputs
around as (potentially un-aligned) byte strings, but can operate on words
made out of those byte strings.
This occurs (for example) in AES when loading blocks and keys (which may not
be word aligned) into registers to perform the round functions.
====

===== Crossbar Permutation Instructions

----
RV32, RV64:
    xperm4 rd, rs1, rs2
    xperm8 rd, rs1, rs2
----

See cite:[riscv:bitmanip:draft] (Section 2.2.4) for a complete
description of this instruction.

The `xperm4` instruction operates on nibbles.
`GPR[rs1]` contains a vector of `XLEN/4` 4-bit elements.
`GPR[rs2]` contains a vector of `XLEN/4` 4-bit indexes.
The result is each element in `GPR[rs2]` replaced by the indexed element
in `GPR[rs1]`, or zero if the index into `GPR[rs2]` is out of bounds.

The `xperm8` instruction operates on bytes.
`GPR[rs1]` contains a vector of `XLEN/8` 8-bit elements.
`GPR[rs2]` contains a vector of `XLEN/8` 8-bit indexes.
The result is each element in `GPR[rs2]` replaced by the indexed element
in `GPR[rs1]`, or zero if the index into `GPR[rs2]` is out of bounds.

.Notes to software developers
[NOTE,caption="SH"]
====
The instruction can be used to implement arbitrary bit
permutations.
For cryptography, they can accelerate bit-sliced implementations,
permutation layers of block ciphers, masking based countermeasures
and SBox operations.

Lightweight block ciphers using 4-bit SBoxes include:
PRESENT cite:[block:present],
Rectangle cite:[block:rectangle],
GIFT cite:[block:gift],
Twine cite:[block:twine],
Skinny, MANTIS cite:[block:skinny],
Midori cite:[block:midori].

National ciphers using 8-bit SBoxes include:
Camellia cite:[block:camellia] (Japan), 
Aria cite:[block:aria] (Korea),
AES cite:[nist:fips:197] (USA, Belgium),
SM4 cite:[gbt:sm4] (China)
Kuznyechik (Russia).

All of these SBoxes can be implemented efficiently, in constant
time, using the `xperm8` instruction
footnote:l[link:http://svn.clairexen.net/handicraft/2020/lut4perm/demo02.cc[]].
Note that this technique is also suitable for masking based
side-channel countermeasures.
====

