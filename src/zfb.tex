\chapter{``Zfb'' Standard Extension for Additional Floating-Point
Instructions, Version 0.1}
\label{chap:zfb}

This chapter describes the Zfb standard extension, which adds instructions for
quiet floating-point comparisons and for the IEEE 754-2019 minimum and maximum
operations.
For RV32D, the Zfb extension also adds instructions to transfer
double-precision floating-point values to and from integer registers, and for
RV64Q, it adds analogous instructions for quad-precision floating-point
values.
The Zfb extension depends on the F extension.

\section{Minimum and Maximum Instructions}

The FMINI.S and FMAXI.S instructions are defined like the FMIN.S and FMAX.S
instructions, except that if either input is NaN, the result is the
canonical NaN.

If the D extension is implemented, FMINI.D and FMAXI.D instructions are
analogously defined to operate on double-precision numbers.

If the Zfh extension is implemented, FMINI.H and FMAXI.H instructions are
analogously defined to operate on half-precision numbers.

If the Q extension is implemented, FMINI.Q and FMAXI.Q instructions are
analogously defined to operate on quad-precision numbers.

These instructions are encoded like their FMIN and FMAX counterparts, but
with instruction bit 13 set to 1.

\begin{commentary}
These instructions implement the IEEE 754-2019 minimum and maximum operations.
\end{commentary}


\section{Comparison Instructions}

The FLEQ.S and FLTQ.S instructions are defined like the FLE.S and FLT.S
instructions, except that quiet NaN inputs do not cause the invalid
operation exception flag to be set.

If the D extension is implemented, FLEQ.D and FLTQ.D instructions are
analogously defined to operate on double-precision numbers.

If the Zfh extension is implemented, FLEQ.H and FLTQ.H instructions are
analogously defined to operate on half-precision numbers.

If the Q extension is implemented, FLEQ.Q and FLTQ.Q instructions are
analogously defined to operate on quad-precision numbers.

These instructions are encoded like their FLE and FLT counterparts, but
with instruction bit 14 set to 1.

\begin{commentary}
We do not expect analogous comparison instructions will be added to the vector
ISA, since they can be reasonably efficiently emulated using masking.
\end{commentary}


\section{Move Instructions}

For RV32 only, if the D extension is implemented,
the FMVH.X.D instruction moves bits 63:32 of floating-point register {\em rs1}
into integer register {\em rd}.
It is encoded in the OP-FP major opcode with {\em funct3}=0, {\em rs2}=1,
and {\em funct7}=1110001.

\begin{commentary}
FMVH.X.D is used in conjunction with the existing FMV.X.W instruction to move
a double-precision floating-point number to a pair of x-registers.
\end{commentary}

For RV32 only, if the D extension is implemented,
the FMVP.D.X instruction moves a double-precision number from a pair of integer
registers into a floating-point register.  Integer registers {\em rs1} and
{\em rs2} supply bits 31:0 and 63:32, respectively; the result is written to
floating-point register {\em rd}.
FMVP.D.X is encoded in the OP-FP major opcode with {\em funct3}=0
and {\em funct7}=1011001.

For RV64 only, if the Q extension is implemented,
the FMVH.X.Q instruction moves bits 127:64 of floating-point register {\em rs1}
into integer register {\em rd}.
It is encoded in the OP-FP major opcode with {\em funct3}=0, {\em rs2}=1,
and {\em funct7}=1110011.

\begin{commentary}
FMVH.X.Q is used in conjunction with the existing FMV.X.D instruction to move
a quad-precision floating-point number to a pair of x-registers.
\end{commentary}

For RV64 only, if the Q extension is implemented,
the FMVP.Q.X instruction moves a double-precision number from a pair of integer
registers into a floating-point register.  Integer registers {\em rs1} and
{\em rs2} supply bits 63:0 and 127:64, respectively; the result is written to
floating-point register {\em rd}.
FMVP.Q.X is encoded in the OP-FP major opcode with {\em funct3}=0
and {\em funct7}=1011011.
