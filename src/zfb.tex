\chapter{``Zfb'' Standard Extension for Additional Floating-Point
Instructions, Version 0.1}
\label{chap:zfb}

This chapter describes the Zfb standard extension, which adds instructions for
quiet floating-point comparisons, IEEE 754-2019 minimum and maximum
operations, and round-to-integer operations.
For RV32D, the Zfb extension also adds instructions to transfer
double-precision floating-point values to and from integer registers, and for
RV64Q, it adds analogous instructions for quad-precision floating-point
values.
The Zfb extension depends on the F extension.

\section{Minimum and Maximum Instructions}

The FMINI.S and FMAXI.S instructions are defined like the FMIN.S and FMAX.S
instructions, except that if either input is NaN, the result is the
canonical NaN.

If the D extension is implemented, FMINI.D and FMAXI.D instructions are
analogously defined to operate on double-precision numbers.

If the Zfh extension is implemented, FMINI.H and FMAXI.H instructions are
analogously defined to operate on half-precision numbers.

If the Q extension is implemented, FMINI.Q and FMAXI.Q instructions are
analogously defined to operate on quad-precision numbers.

These instructions are encoded like their FMIN and FMAX counterparts, but
with instruction bit 13 set to 1.

\begin{commentary}
These instructions implement the IEEE 754-2019 minimum and maximum operations.
\end{commentary}


\section{Round-to-Integer Instructions}

The FROUND.S instruction rounds the single-precision floating-point number in
floating-point register {\em rs1} to an integer, according to the rounding
mode specified in the instruction's {\em rm} field.
It then writes that integer, represented as a single-precision floating-point
number, to floating-point register {\em rd}.
Zero and infinite inputs are copied to {\em rd} unmodified.
Signaling NaN inputs cause the invalid operation exception flag to be set; no
other exception flags are set.
FROUND.S is encoded like FCVT.S.D, but with {\em rs2}=4.

The FROUND.NX.S instruction is defined similarly, but it also sets the inexact
exception flag if the input differs from the rounded result and is not NaN.
FROUND.NX.S is encoded like FCVT.S.D, but with {\em rs2}=5.

If the D extension is implemented, FROUND.D and FROUND.NX.D instructions are
analogously defined to operate on double-precision numbers.
They are encoded like FCVT.D.S, but with {\em rs2}=4 and 5, respectively,

If the Zfh extension is implemented, FROUND.H and FROUND.NX.H instructions are
analogously defined to operate on half-precision numbers.
They are encoded like FCVT.H.S, but with {\em rs2}=4 and 5, respectively,

If the Q extension is implemented, FROUND.Q and FROUND.NX.Q instructions are
analogously defined to operate on quad-precision numbers.
They are encoded like FCVT.Q.S, but with {\em rs2}=4 and 5, respectively,

\begin{commentary}
The FROUND.NX.{\em fmt} instructions implement the IEEE 754-2019
roundToIntegralExact operation, and the FROUND.{\em fmt} instructions
implement the other operations in the roundToIntegral family.
\end{commentary}


\section{Comparison Instructions}

The FLEQ.S and FLTQ.S instructions are defined like the FLE.S and FLT.S
instructions, except that quiet NaN inputs do not cause the invalid
operation exception flag to be set.

If the D extension is implemented, FLEQ.D and FLTQ.D instructions are
analogously defined to operate on double-precision numbers.

If the Zfh extension is implemented, FLEQ.H and FLTQ.H instructions are
analogously defined to operate on half-precision numbers.

If the Q extension is implemented, FLEQ.Q and FLTQ.Q instructions are
analogously defined to operate on quad-precision numbers.

These instructions are encoded like their FLE and FLT counterparts, but
with instruction bit 14 set to 1.

\begin{commentary}
We do not expect analogous comparison instructions will be added to the vector
ISA, since they can be reasonably efficiently emulated using masking.
\end{commentary}


\section{Move Instructions}

For RV32 only, if the D extension is implemented,
the FMVH.X.D instruction moves bits 63:32 of floating-point register {\em rs1}
into integer register {\em rd}.
It is encoded in the OP-FP major opcode with {\em funct3}=0, {\em rs2}=1,
and {\em funct7}=1110001.

\begin{commentary}
FMVH.X.D is used in conjunction with the existing FMV.X.W instruction to move
a double-precision floating-point number to a pair of x-registers.
\end{commentary}

For RV32 only, if the D extension is implemented,
the FMVP.D.X instruction moves a double-precision number from a pair of integer
registers into a floating-point register.  Integer registers {\em rs1} and
{\em rs2} supply bits 31:0 and 63:32, respectively; the result is written to
floating-point register {\em rd}.
FMVP.D.X is encoded in the OP-FP major opcode with {\em funct3}=0
and {\em funct7}=1011001.

For RV64 only, if the Q extension is implemented,
the FMVH.X.Q instruction moves bits 127:64 of floating-point register {\em rs1}
into integer register {\em rd}.
It is encoded in the OP-FP major opcode with {\em funct3}=0, {\em rs2}=1,
and {\em funct7}=1110011.

\begin{commentary}
FMVH.X.Q is used in conjunction with the existing FMV.X.D instruction to move
a quad-precision floating-point number to a pair of x-registers.
\end{commentary}

For RV64 only, if the Q extension is implemented,
the FMVP.Q.X instruction moves a double-precision number from a pair of integer
registers into a floating-point register.  Integer registers {\em rs1} and
{\em rs2} supply bits 63:0 and 127:64, respectively; the result is written to
floating-point register {\em rd}.
FMVP.Q.X is encoded in the OP-FP major opcode with {\em funct3}=0
and {\em funct7}=1011011.
