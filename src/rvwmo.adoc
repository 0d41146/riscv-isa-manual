[[memorymodel]]
== RVWMO Memory Consistency Model, Version 2.0

This chapter defines the RISC-V memory consistency model. A memory
consistency model is a set of rules specifying the values that can be
returned by loads of memory. RISC-V uses a memory model called `RVWMO`
(RISC-V Weak Memory Ordering) which is designed to provide flexibility
for architects to build high-performance scalable designs while
simultaneously supporting a tractable programming model.
(((design, high performace)))
(((design, scalable)))

Under RVWMO, code running on a single hart appears to execute in order
from the perspective of other memory instructions in the same hart, but
memory instructions from another hart may observe the memory
instructions from the first hart being executed in a different order.
Therefore, multithreaded code may require explicit synchronization to
guarantee ordering between memory instructions from different harts. The
base RISC-V ISA provides a FENCE instruction for this purpose, described
in <<fence>>, while the atomics extension `A`
additionally defines load-reserved/store-conditional and atomic
read-modify-write instructions.
(((atomics, misaligned)))

The standard ISA extension for misaligned atomics `Zam`
(<<zam>>) and the standard ISA extension for total
store ordering `Ztso` (<<ztso>>) augment RVWMO
with additional rules specific to those extensions.

The appendices to this specification provide both axiomatic and
operational formalizations of the memory consistency model as well as
additional explanatory material.
((FENCE))
((SFENCE))

This chapter defines the memory model for regular main memory
operations. The interaction of the memory model with I/O memory,
instruction fetches, FENCE.I, page table walks, and SFENCE.VMA is not
(yet) formalized. Some or all of the above may be formalized in a future
revision of this specification. The RV128 base ISA and future ISA
extensions such as the `V` vector and `J` JIT extensions will need
to be incorporated into a future revision as well.

Memory consistency models supporting overlapping memory accesses of
different widths simultaneously remain an active area of academic
research and are not yet fully understood. The specifics of how memory
accesses of different sizes interact under RVWMO are specified to the
best of our current abilities, but they are subject to revision should
new issues be uncovered.

[[rvwmo]]
=== Definition of the RVWMO Memory Model

The RVWMO memory model is defined in terms of the _global memory order_,
a total ordering of the memory operations produced by all harts. In
general, a multithreaded program has many different possible executions,
with each execution having its own corresponding global memory order.
((RVWMO))

The global memory order is defined over the primitive load and store
operations generated by memory instructions. It is then subject to the
constraints defined in the rest of this chapter. Any execution
satisfying all of the memory model constraints is a legal execution (as
far as the memory model is concerned).

[[rvwmo-primitives]]
==== Memory Model Primitives

The _program order_ over memory operations reflects the order in which
the instructions that generate each load and store are logically laid
out in that hart’s dynamic instruction stream; i.e., the order in which
a simple in-order processor would execute the instructions of that hart.

Memory-accessing instructions give rise to _memory operations_. A memory
operation can be either a _load operation_, a _store operation_, or both
simultaneously. All memory operations are single-copy atomic: they can
never be observed in a partially complete state.
(((operations, memory)))

Among instructions in RV32GC and RV64GC, each aligned memory instruction
gives rise to exactly one memory operation, with two exceptions. First,
an unsuccessful SC instruction does not give rise to any memory
operations. Second, FLD and FSD instructions may each give rise to
multiple memory operations if XLENlatexmath:[$<$]64, as stated in
<<fld_fsd>> and clarified below. An aligned AMO
gives rise to a single memory operation that is both a load operation
and a store operation simultaneously.

Instructions in the RV128 base instruction set and in future ISA
extensions such as V (vector) and P (SIMD) may give rise to multiple
memory operations. However, the memory model for these extensions has
not yet been formalized.

A misaligned load or store instruction may be decomposed into a set of
component memory operations of any granularity. An FLD or FSD
instruction for which XLENlatexmath:[$<$]64 may also be decomposed into
a set of component memory operations of any granularity. The memory
operations generated by such instructions are not ordered with respect
to each other in program order, but they are ordered normally with
respect to the memory operations generated by preceding and subsequent
instructions in program order. The atomics extension `A` does not
require execution environments to support misaligned atomic instructions
at all; however, if misaligned atomics are supported via the `Zam`
extension, LRs, SCs, and AMOs may be decomposed subject to the
constraints of the atomicity axiom for misaligned atomics, which is
defined in <<zam>>.
((decomposition))

The decomposition of misaligned memory operations down to byte
granularity facilitates emulation on implementations that do not
natively support misaligned accesses. Such implementations might, for
example, simply iterate over the bytes of a misaligned access one by
one.

An LR instruction and an SC instruction are said to be _paired_ if the
LR precedes the SC in program order and if there are no other LR or SC
instructions in between; the corresponding memory operations are said to
be paired as well (except in case of a failed SC, where no store
operation is generated). The complete list of conditions determining
whether an SC must succeed, may succeed, or must fail is defined in
<<lrsc>>.

Load and store operations may also carry one or more ordering
annotations from the following set: `acquire-RCpc`, `acquire-RCsc`,
`release-RCpc`, and `release-RCsc`. An AMO or LR instruction with
_aq_ set has an `acquire-RCsc` annotation. An AMO or SC instruction
with _rl_ set has a `release-RCsc` annotation. An AMO, LR, or SC
instruction with both _aq_ and _rl_ set has both `acquire-RCsc` and
`release-RCsc` annotations.

For convenience, we use the term `acquire annotation` to refer to an
acquire-RCpc annotation or an acquire-RCsc annotation. Likewise, a
`release annotation` refers to a release-RCpc annotation or a
release-RCsc annotation. An `RCpc annotation` refers to an
acquire-RCpc annotation or a release-RCpc annotation. An `RCsc
annotation` refers to an acquire-RCsc annotation or a release-RCsc
annotation.

In the memory model literature, the term `RCpc` stands for release
consistency with processor-consistent synchronization operations, and
the term `RCsc` stands for release consistency with sequentially
consistent synchronization operations .

While there are many different definitions for acquire and release
annotations in the literature, in the context of RVWMO these terms are
concisely and completely defined by Preserved Program Order rules
<<rcsc>>.

`RCpc` annotations are currently only used when implicitly assigned to
every memory access per the standard extension `Ztso`
(<<ztso>>). Furthermore, although the ISA does not
currently contain native load-acquire or store-release instructions, nor
RCpc variants thereof, the RVWMO model itself is designed to be
forwards-compatible with the potential addition of any or all of the
above into the ISA in a future extension.

[[mem-dependencies]]
==== Syntactic Dependencies

The definition of the RVWMO memory model depends in part on the notion
of a syntactic dependency, defined as follows.

In the context of defining dependencies, a `register` refers either to
an entire general-purpose register, some portion of a CSR, or an entire
CSR. The granularity at which dependencies are tracked through CSRs is
specific to each CSR and is defined in
<<csr-granularity>>.

Syntactic dependencies are defined in terms of instructions’ _source
registers_, instructions’ _destination registers_, and the way
instructions _carry a dependency_ from their source registers to their
destination registers. This section provides a general definition of all
of these terms; however, <<source-dest-regs>> provides a
complete listing of the specifics for each instruction.

In general, a register latexmath:[$r$] other than `x0` is a _source
register_ for an instruction latexmath:[$i$] if any of the following
hold:

* In the opcode of latexmath:[$i$], _rs1_, _rs2_, or _rs3_ is set to
latexmath:[$r$]
* latexmath:[$i$] is a CSR instruction, and in the opcode of
latexmath:[$i$], _csr_ is set to latexmath:[$r$], unless latexmath:[$i$]
is CSRRW or CSRRWI and _rd_ is set to `x0`
* latexmath:[$r$] is a CSR and an implicit source register for
latexmath:[$i$], as defined in <<source-dest-regs>>
* latexmath:[$r$] is a CSR that aliases with another source register for
latexmath:[$i$]

Memory instructions also further specify which source registers are
_address source registers_ and which are _data source registers_.

In general, a register latexmath:[$r$] other than `x0` is a _destination
register_ for an instruction latexmath:[$i$] if any of the following
hold:

* In the opcode of latexmath:[$i$], _rd_ is set to latexmath:[$r$]
* latexmath:[$i$] is a CSR instruction, and in the opcode of
latexmath:[$i$], _csr_ is set to latexmath:[$r$], unless latexmath:[$i$]
is CSRRS or CSRRC and _rs1_ is set to `x0` or latexmath:[$i$] is CSRRSI
or CSRRCI and uimm[4:0] is set to zero.
* latexmath:[$r$] is a CSR and an implicit destination register for
latexmath:[$i$], as defined in <<source-dest-regs>>
* latexmath:[$r$] is a CSR that aliases with another destination
register for latexmath:[$i$]

Most non-memory instructions _carry a dependency_ from each of their
source registers to each of their destination registers. However, there
are exceptions to this rule; see <<>>source-dest-regs>>.

Instruction latexmath:[$j$] has a _syntactic dependency_ on instruction
latexmath:[$i$] via destination register latexmath:[$s$] of
latexmath:[$i$] and source register latexmath:[$r$] of latexmath:[$j$]
if either of the following hold:

* latexmath:[$s$] is the same as latexmath:[$r$], and no instruction
program-ordered between latexmath:[$i$] and latexmath:[$j$] has
latexmath:[$r$] as a destination register
* There is an instruction latexmath:[$m$] program-ordered between
latexmath:[$i$] and latexmath:[$j$] such that all of the following hold:
. latexmath:[$j$] has a syntactic dependency on latexmath:[$m$] via
destination register latexmath:[$q$] and source register latexmath:[$r$]
. latexmath:[$m$] has a syntactic dependency on latexmath:[$i$] via
destination register latexmath:[$s$] and source register latexmath:[$p$]
. latexmath:[$m$] carries a dependency from latexmath:[$p$] to
latexmath:[$q$]

Finally, in the definitions that follow, let latexmath:[$a$] and
latexmath:[$b$] be two memory operations, and let latexmath:[$i$] and
latexmath:[$j$] be the instructions that generate latexmath:[$a$] and
latexmath:[$b$], respectively.

latexmath:[$b$] has a _syntactic address dependency_ on latexmath:[$a$]
if latexmath:[$r$] is an address source register for latexmath:[$j$] and
latexmath:[$j$] has a syntactic dependency on latexmath:[$i$] via source
register latexmath:[$r$]

latexmath:[$b$] has a _syntactic data dependency_ on latexmath:[$a$] if
latexmath:[$b$] is a store operation, latexmath:[$r$] is a data source
register for latexmath:[$j$], and latexmath:[$j$] has a syntactic
dependency on latexmath:[$i$] via source register latexmath:[$r$]

latexmath:[$b$] has a _syntactic control dependency_ on latexmath:[$a$]
if there is an instruction latexmath:[$m$] program-ordered between
latexmath:[$i$] and latexmath:[$j$] such that latexmath:[$m$] is a
branch or indirect jump and latexmath:[$m$] has a syntactic dependency
on latexmath:[$i$].

Generally speaking, non-AMO load instructions do not have data source
registers, and unconditional non-AMO store instructions do not have
destination registers. However, a successful SC instruction is
considered to have the register specified in _rd_ as a destination
register, and hence it is possible for an instruction to have a
syntactic dependency on a successful SC instruction that precedes it in
program order.

==== Preserved Program Order

The global memory order for any given execution of a program respects
some but not all of each hart’s program order. The subset of program
order that must be respected by the global memory order is known as
_preserved program order_.

The complete definition of preserved program order is as follows (and
note that AMOs are simultaneously both loads and stores): memory
operation latexmath:[$a$] precedes memory operation latexmath:[$b$] in
preserved program order (and hence also in the global memory order) if
latexmath:[$a$] precedes latexmath:[$b$] in program order,
latexmath:[$a$] and latexmath:[$b$] both access regular main memory
(rather than I/O regions), and any of the following hold:

[[overlapping-orering]]
* Overlapping-Address Orderings:
. latexmath:[$b$] is a store, and
latexmath:[$a$] and latexmath:[$b$] access overlapping memory addresses
. latexmath:[$a$] and latexmath:[$b$] are loads,
latexmath:[$x$] is a byte read by both latexmath:[$a$] and
latexmath:[$b$], there is no store to latexmath:[$x$] between
latexmath:[$a$] and latexmath:[$b$] in program order, and
latexmath:[$a$] and latexmath:[$b$] return values for latexmath:[$x$]
written by different memory operations
. latexmath:[$a$] is
generated by an AMO or SC instruction, latexmath:[$b$] is a load, and
latexmath:[$b$] returns a value written by latexmath:[$a$]
* Explicit Synchronization
. There is a FENCE instruction that
orders latexmath:[$a$] before latexmath:[$b$]
. latexmath:[$a$] has an acquire
annotation
. latexmath:[$b$] has a release annotation
. latexmath:[$a$] and latexmath:[$b$] both have
RCsc annotations
. {empty} latexmath:[$a$] is paired with
latexmath:[$b$]
* Syntactic Dependencies
. latexmath:[$b$] has a syntactic address
dependency on latexmath:[$a$]
. latexmath:[$b$] has a syntactic data
dependency on latexmath:[$a$]
. latexmath:[$b$] is a store, and
latexmath:[$b$] has a syntactic control dependency on latexmath:[$a$]
* Pipeline Dependencies
. latexmath:[$b$] is a
load, and there exists some store latexmath:[$m$] between
latexmath:[$a$] and latexmath:[$b$] in program order such that
latexmath:[$m$] has an address or data dependency on latexmath:[$a$],
and latexmath:[$b$] returns a value written by latexmath:[$m$]
. latexmath:[$b$] is a store, and
there exists some instruction latexmath:[$m$] between latexmath:[$a$]
and latexmath:[$b$] in program order such that latexmath:[$m$] has an
address dependency on latexmath:[$a$]

==== Memory Model Axioms

An execution of a RISC-V program obeys the RVWMO memory consistency
model only if there exists a global memory order conforming to preserved
program order and satisfying the _load value axiom_, the _atomicity
axiom_, and the _progress axiom_.

[[ax-load]]
===== Load Value Axiom

Each byte of each load latexmath:[$i$] returns the value written to that
byte by the store that is the latest in global memory order among the
following stores:

. Stores that write that byte and that precede latexmath:[$i$] in the
global memory order
. Stores that write that byte and that precede latexmath:[$i$] in
program order

[[ax-atom]]
===== Atomicity Axiom

If latexmath:[$r$] and latexmath:[$w$] are paired load and store
operations generated by aligned LR and SC instructions in a hart
latexmath:[$h$], latexmath:[$s$] is a store to byte latexmath:[$x$], and
latexmath:[$r$] returns a value written by latexmath:[$s$], then
latexmath:[$s$] must precede latexmath:[$w$] in the global memory order,
and there can be no store from a hart other than latexmath:[$h$] to byte
latexmath:[$x$] following latexmath:[$s$] and preceding latexmath:[$w$]
in the global memory order.

The theoretically supports LR/SC pairs of different widths and to
mismatched addresses, since implementations are permitted to allow SC
operations to succeed in such cases. However, in practice, we expect
such patterns to be rare, and their use is discouraged.

[[ax-prog]]
===== Progress Axiom

No memory operation may be preceded in the global memory order by an
infinite sequence of other memory operations.

[[sec:csr-granularity]]
=== CSR Dependency Tracking Granularity

.Granularities at which syntactic dependencies are tracked through CSRs
[cols="<,<,<",options="header",]
|===
|Name |Portions Tracked as Independent Units |Aliases
|`fflags` |Bits 4, 3, 2, 1, 0 |`fcsr`
|`frm` |entire CSR |`fcsr`
|`fcsr` |Bits 7-5, 4, 3, 2, 1, 0 |`fflags`, `frm`
|===

Note: read-only CSRs are not listed, as they do not participate in the
definition of syntactic dependencies.

[[sec:source-dest-regs]]
=== Source and Destination Register Listings

This section provides a concrete listing of the source and destination
registers for each instruction. These listings are used in the
definition of syntactic dependencies in
<<mem-dependencies>>.

The term `accumulating CSR` is used to describe a CSR that is both a
source and a destination register, but which carries a dependency only
from itself to itself.

Instructions carry a dependency from each source register in the
`Source Registers` column to each destination register in the
`Destination Registers` column, from each source register in the
`Source Registers` column to each CSR in the `Accumulating CSRs`
column, and from each CSR in the `Accumulating CSRs` column to itself,
except where annotated otherwise.

Key:

latexmath:[$^A$]Address source register

latexmath:[$^D$]Data source register

latexmath:[$^\dagger$]The instruction does not carry a dependency from
any source register to any destination register

latexmath:[$^\ddagger$]The instruction carries dependencies from source
register(s) to destination register(s) as specified

[cols="<,<,<,<",]
|===
|*RV32I Base Integer Instruction Set* | | |
| |Source |Destination |Accumulating
| |Registers |Registers |CSRs
|LUI | |_rd_ |
|AUIPC | |_rd_ |
|JAL | |_rd_ |
|JALRlatexmath:[$^\dagger$] |_rs1_ |_rd_ |
|BEQ |_rs1_, _rs2_ | |
|BNE |_rs1_, _rs2_ | |
|BLT |_rs1_, _rs2_ | |
|BGE |_rs1_, _rs2_ | |
|BLTU |_rs1_, _rs2_ | |
|BGEU |_rs1_, _rs2_ | |
|LBlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ |
|LHlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ |
|LWlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ |
|LBUlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ |
|LHUlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ |
|SB |_rs1_latexmath:[$^A$], _rs2_latexmath:[$^D$] | |
|SH |_rs1_latexmath:[$^A$], _rs2_latexmath:[$^D$] | |
|SW |_rs1_latexmath:[$^A$], _rs2_latexmath:[$^D$] | |
|ADDI |_rs1_ |_rd_ |
|SLTI |_rs1_ |_rd_ |
|SLTIU |_rs1_ |_rd_ |
|XORI |_rs1_ |_rd_ |
|ORI |_rs1_ |_rd_ |
|ANDI |_rs1_ |_rd_ |
|SLLI |_rs1_ |_rd_ |
|SRLI |_rs1_ |_rd_ |
|SRAI |_rs1_ |_rd_ |
|ADD |_rs1_, _rs2_ |_rd_ |
|SUB |_rs1_, _rs2_ |_rd_ |
|SLL |_rs1_, _rs2_ |_rd_ |
|SLT |_rs1_, _rs2_ |_rd_ |
|SLTU |_rs1_, _rs2_ |_rd_ |
|XOR |_rs1_, _rs2_ |_rd_ |
|SRL |_rs1_, _rs2_ |_rd_ |
|SRA |_rs1_, _rs2_ |_rd_ |
|OR |_rs1_, _rs2_ |_rd_ |
|AND |_rs1_, _rs2_ |_rd_ |
|FENCE | | |
|FENCE.I | | |
|ECALL | | |
|EBREAK | | |
|===

[cols="<,<,<,<,<",]
|===
|*RV32I Base Integer Instruction Set (continued)* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|CSRRWlatexmath:[$^\ddagger$] |_rs1_, _csr_latexmath:[$^*$] |_rd_, _csr_
| |latexmath:[$^*$]unless _rd_=`x0`

|CSRRSlatexmath:[$^\ddagger$] |_rs1_, _csr_ |_rd_latexmath:[$^*$], _csr_
| |latexmath:[$^*$]unless _rs1_=`x0`

|CSRRClatexmath:[$^\ddagger$] |_rs1_, _csr_ |_rd_latexmath:[$^*$], _csr_
| |latexmath:[$^*$]unless _rs1_=`x0`

| |latexmath:[$\ddagger$]carries a dependency from _rs1_ to _csr_ and
from _csr_ to _rd_ | | |
|===

[cols="<,<,<,<,<",]
|===
|*RV32I Base Integer Instruction Set (continued)* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|CSRRWIlatexmath:[$^\ddagger$] |_csr_latexmath:[$^*$] |_rd_, _csr_ |
|latexmath:[$^*$]unless _rd_=`x0`

|CSRRSIlatexmath:[$^\ddagger$] |_csr_ |_rd_, _csr_latexmath:[$^*$] |
|latexmath:[$^*$]unless uimm[4:0]=0

|CSRRCIlatexmath:[$^\ddagger$] |_csr_ |_rd_, _csr_latexmath:[$^*$] |
|latexmath:[$^*$]unless uimm[4:0]=0

| |latexmath:[$\ddagger$]carries a dependency from _csr_ to _rd_ | | |
|===

[cols="<,<,<,<",]
|===
|*RV64I Base Integer Instruction Set* | | |
| |Source |Destination |Accumulating
| |Registers |Registers |CSRs
|LWUlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ |
|LDlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ |
|SD |_rs1_latexmath:[$^A$], _rs2_latexmath:[$^D$] | |
|SLLI |_rs1_ |_rd_ |
|SRLI |_rs1_ |_rd_ |
|SRAI |_rs1_ |_rd_ |
|ADDIW |_rs1_ |_rd_ |
|SLLIW |_rs1_ |_rd_ |
|SRLIW |_rs1_ |_rd_ |
|SRAIW |_rs1_ |_rd_ |
|ADDW |_rs1_, _rs2_ |_rd_ |
|SUBW |_rs1_, _rs2_ |_rd_ |
|SLLW |_rs1_, _rs2_ |_rd_ |
|SRLW |_rs1_, _rs2_ |_rd_ |
|SRAW |_rs1_, _rs2_ |_rd_ |
|===

[cols="<,<,<,<",]
|===
|*RV32M Standard Extension* | | |
| |Source |Destination |Accumulating
| |Registers |Registers |CSRs
|MUL |_rs1_, _rs2_ |_rd_ |
|MULH |_rs1_, _rs2_ |_rd_ |
|MULHSU |_rs1_, _rs2_ |_rd_ |
|MULHU |_rs1_, _rs2_ |_rd_ |
|DIV |_rs1_, _rs2_ |_rd_ |
|DIVU |_rs1_, _rs2_ |_rd_ |
|REM |_rs1_, _rs2_ |_rd_ |
|REMU |_rs1_, _rs2_ |_rd_ |
|===

[cols="<,<,<,<",]
|===
|*RV64M Standard Extension* | | |
| |Source |Destination |Accumulating
| |Registers |Registers |CSRs
|MULW |_rs1_, _rs2_ |_rd_ |
|DIVW |_rs1_, _rs2_ |_rd_ |
|DIVUW |_rs1_, _rs2_ |_rd_ |
|REMW |_rs1_, _rs2_ |_rd_ |
|REMUW |_rs1_, _rs2_ |_rd_ |
|===

[cols="<,<,<,<,<",]
|===
|*RV32A Standard Extension* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|LR.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ | |

|SC.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_latexmath:[$^*$] | |latexmath:[$^*$]if
successful

|AMOSWAP.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOADD.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOXOR.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOAND.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOOR.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMIN.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMAX.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMINU.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMAXU.Wlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|===

[cols="<,<,<,<,<",]
|===
|*RV64A Standard Extension* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|LR.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ | |

|SC.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_latexmath:[$^*$] | |latexmath:[$^*$]if
successful

|AMOSWAP.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOADD.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOXOR.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOAND.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOOR.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMIN.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMAX.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMINU.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|AMOMAXU.Dlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$],
_rs2_latexmath:[$^D$] |_rd_ | |

|===

[cols="<,<,<,<,<",]
|===
|*RV32F Standard Extension* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|FLWlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ | |

|FSW |_rs1_latexmath:[$^A$], _rs2_latexmath:[$^D$] | | |

|FMADD.S |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FMSUB.S |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FNMSUB.S |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF,
NX |latexmath:[$^*$]if rm=111

|FNMADD.S |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF,
NX |latexmath:[$^*$]if rm=111

|FADD.S |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, OF, NX
|latexmath:[$^*$]if rm=111

|FSUB.S |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, OF, NX
|latexmath:[$^*$]if rm=111

|FMUL.S |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FDIV.S |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, DZ, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FSQRT.S |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FSGNJ.S |_rs1_, _rs2_ |_rd_ | |

|FSGNJN.S |_rs1_, _rs2_ |_rd_ | |

|FSGNJX.S |_rs1_, _rs2_ |_rd_ | |

|FMIN.S |_rs1_, _rs2_ |_rd_ |NV |

|FMAX.S |_rs1_, _rs2_ |_rd_ |NV |

|FCVT.W.S |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FCVT.WU.S |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FMV.X.W |_rs1_ |_rd_ | |

|FEQ.S |_rs1_, _rs2_ |_rd_ |NV |

|FLT.S |_rs1_, _rs2_ |_rd_ |NV |

|FLE.S |_rs1_, _rs2_ |_rd_ |NV |

|FCLASS.S |_rs1_ |_rd_ | |

|FCVT.S.W |_rs1_, frmlatexmath:[$^*$] |_rd_ |NX |latexmath:[$^*$]if
rm=111

|FCVT.S.WU |_rs1_, frmlatexmath:[$^*$] |_rd_ |NX |latexmath:[$^*$]if
rm=111

|FMV.W.X |_rs1_ |_rd_ | |

|===

[cols="<,<,<,<,<",]
|===
|*RV64F Standard Extension* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|FCVT.L.S |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FCVT.LU.S |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FCVT.S.L |_rs1_, frmlatexmath:[$^*$] |_rd_ |NX |latexmath:[$^*$]if
rm=111

|FCVT.S.LU |_rs1_, frmlatexmath:[$^*$] |_rd_ |NX |latexmath:[$^*$]if
rm=111

|===

[cols="<,<,<,<,<",]
|===
|*RV32D Standard Extension* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|FLDlatexmath:[$^\dagger$] |_rs1_latexmath:[$^A$] |_rd_ | |

|FSD |_rs1_latexmath:[$^A$], _rs2_latexmath:[$^D$] | | |

|FMADD.D |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FMSUB.D |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FNMSUB.D |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF,
NX |latexmath:[$^*$]if rm=111

|FNMADD.D |_rs1_, _rs2_, _rs3_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF,
NX |latexmath:[$^*$]if rm=111

|FADD.D |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, OF, NX
|latexmath:[$^*$]if rm=111

|FSUB.D |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, OF, NX
|latexmath:[$^*$]if rm=111

|FMUL.D |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FDIV.D |_rs1_, _rs2_, frmlatexmath:[$^*$] |_rd_ |NV, DZ, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FSQRT.D |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FSGNJ.D |_rs1_, _rs2_ |_rd_ | |

|FSGNJN.D |_rs1_, _rs2_ |_rd_ | |

|FSGNJX.D |_rs1_, _rs2_ |_rd_ | |

|FMIN.D |_rs1_, _rs2_ |_rd_ |NV |

|FMAX.D |_rs1_, _rs2_ |_rd_ |NV |

|FCVT.S.D |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, OF, UF, NX
|latexmath:[$^*$]if rm=111

|FCVT.D.S |_rs1_ |_rd_ |NV |

|FEQ.D |_rs1_, _rs2_ |_rd_ |NV |

|FLT.D |_rs1_, _rs2_ |_rd_ |NV |

|FLE.D |_rs1_, _rs2_ |_rd_ |NV |

|FCLASS.D |_rs1_ |_rd_ | |

|FCVT.W.D |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FCVT.WU.D |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FCVT.D.W |_rs1_ |_rd_ | |

|FCVT.D.WU |_rs1_ |_rd_ | |

|===

[cols="<,<,<,<,<",]
|===
|*RV64D Standard Extension* | | | |

| |Source |Destination |Accumulating |

| |Registers |Registers |CSRs |

|FCVT.L.D |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FCVT.LU.D |_rs1_, frmlatexmath:[$^*$] |_rd_ |NV, NX |latexmath:[$^*$]if
rm=111

|FMV.X.D |_rs1_ |_rd_ | |

|FCVT.D.L |_rs1_, frmlatexmath:[$^*$] |_rd_ |NX |latexmath:[$^*$]if
rm=111

|FCVT.D.LU |_rs1_, frmlatexmath:[$^*$] |_rd_ |NX |latexmath:[$^*$]if
rm=111

|FMV.D.X |_rs1_ |_rd_ | |

|===

